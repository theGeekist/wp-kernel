# Pipeline Extension Contract

_This document describes the canonical extension lifecycle for the shared `@wpkernel/pipeline` orchestrator. Both `@wpkernel/cli` and `@wpkernel/core` consume this contract; see the [CLI Docs Index](../../docs/internal/cli-index.md) for integration notes._

The extension proposal graduates the ad-hoc adapter surface into a first-class pipeline contract. Because both the CLI runtime and the core application shell build on top of `@wpkernel/pipeline`, the contract lives alongside the orchestrator so every consumer shares the same lifecycle description.

## Extension package shape

A deployable extension is an npm workspace that exports three entry points: the configuration factory (`wpk.config.ts`), the pipeline helpers (fragments and builders that ship through the CLI), and a runtime module that feeds hooks into the application shell. The CLI enforces this split by wiring the adapter extension bridge into every IR run, reading the configured factories from `wpk.config.ts`, invoking them, and normalising the returned helpers before the pipeline proceeds.【F:packages/cli/src/ir/createIr.ts†L98-L125】【F:packages/cli/src/runtime/adapterExtensions.ts†L93-L177】 The core package follows the same contract when it registers extensions such as resource finalisers and lifecycle hooks.【F:packages/core/src/pipeline/resources/extensions/createFinalizeResourceDefinitionExtension.ts†L1-L93】

Each factory receives the build options produced from the pipeline invocation (`PipelineRunOptions` in the core package and `BuildIrOptions` in the CLI surface), which include the configuration tree, workspace paths, and reporter wiring. The helpers they return must use the pipeline registration API so that dependency ordering, rollback, and diagnostics remain centralised; helpers that bypass the pipeline cannot participate in the atomic commit protocol.【F:packages/pipeline/src/createPipeline.ts†L604-L772】【F:packages/pipeline/src/extensions.ts†L49-L168】

## Lifecycle hand-off

During `pipeline.run()` the orchestrator finalises fragments, resolves builder ordering, and then pauses to execute the registered extension hooks. Hooks run with the same context object that powered the helpers and the run options derived from the invocation surface. They may swap the artifact before builders execute, enqueue commit or rollback callbacks, or simply observe the run. After hooks finish, builders run, commits fire, and any rollback failures are reported back through the reporter interface.【F:packages/pipeline/src/createPipeline.ts†L817-L959】【F:packages/pipeline/src/extensions.ts†L49-L168】

The extension hook payload today is shaped by `PipelineExtensionHookOptions` in the pipeline package. Consumers such as the CLI re-export this alias so extension authors on those surfaces can depend on the shared contract. Formalising the contract means widening this interface so extensions consume the same context (`args`, `phase`, `meta`, namespace helpers, etc.) that helpers receive. The CLI runtime already passes this data through `createExtensionHookOptions`, so the change is purely typing and ergonomics work for CLI consumers.【F:packages/cli/src/runtime/createPipeline.ts†L128-L134】【F:packages/cli/src/runtime/types.ts†L194-L229】【F:packages/pipeline/src/createPipeline.ts†L706-L735】

### Hook payload shape

`PipelineExtensionHookOptions` re-exports the core pipeline contract. Extension authors receive:

- `context`: the pipeline context, including the workspace, reporter, execution phase, and manifest state.
- `options`: the full `PipelineRunOptions` object passed to `pipeline.run()`. It contains the configuration tree, namespace metadata, invocation source information, workspace accessors, the reporter instance, and the active generation manifest. This replaces the previous `BuildIrOptions` subset on the CLI surface, so hooks can inspect run-scoped data without recasting.
- `artifact`: the IR snapshot generated by fragments prior to builder execution.

Because the type alias threads through the pipeline generics, any future additions to `PipelineRunOptions` automatically flow to every consumer. Regenerate the CLI API docs in `docs/api/@wpkernel/cli/interfaces/PipelineExtensionHookOptions.md` whenever those generics expand so third-party authors see the latest payload contract.【F:docs/api/@wpkernel/cli/interfaces/PipelineExtensionHookOptions.md†L1-L34】

## Authoring extensions with helpers

The pipeline exposes a `createPipelineExtension` helper that wraps the low-level `register()` wiring. The helper accepts optional `setup()` and `hook()` functions so extension packages can register additional helpers during configuration and provide the runtime hook without hand-writing the boilerplate `PipelineExtension` object.【F:packages/pipeline/src/createExtension.ts†L1-L80】 Use `setup()` when the extension needs to add fragment or builder helpers and `hook()` when it wants to participate in the runtime lifecycle.

Both core surfaces already build on the helper. The CLI adapters bridge registers its transactional sandbox by calling `createPipelineExtension` with the generated hook,【F:packages/cli/src/runtime/adapterExtensions.ts†L12-L181】 while the core pipeline relies on the same helper to emit resource definition events after the builders succeed.【F:packages/core/src/pipeline/resources/extensions/createFinalizeResourceDefinitionExtension.ts†L1-L105】 These implementations double as reference templates for extension authors.

## Recommended documentation updates

1. Capture the contract in this document (current step).
2. Mirror any interface or lifecycle adjustments in the generated API docs once the CLI surface matches the pipeline generics.
3. When the `TRunOptions` widening ships, add upgrade guidance to `docs/internal/cli-adapter-dx.md` so downstream extensions know which fields moved and which new context values they gain.

## Next implementation steps

To formalise the contract across consumers:

1. Update the CLI runtime (`packages/cli/src/runtime/types.ts`) so `PipelineExtensionHookOptions` extends the core pipeline shape, exposing `PipelineRunOptions` instead of the build-only subset.
2. Adjust `createPipeline.ts` in the CLI runtime and associated tests to accept the widened options object and re-export the updated types for extension authors.
3. Audit internal extensions (adapter, e2e scaffolds, etc.) and documentation snippets to rely on the top-level run options instead of the nested `options` property.

Once these patches land, link this page to the changelog entry that calls out the breaking type change and the new runtime fields exposed to third-party extensions.
