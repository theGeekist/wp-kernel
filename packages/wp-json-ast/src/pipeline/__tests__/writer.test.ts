import type { PhpProgramAction } from '@wpkernel/php-json-ast';
import { buildProgramTargetPlanner } from '../writer';

describe('buildProgramTargetPlanner', () => {
	it('queues files with resolved paths and merged docblocks', () => {
		const actions: PhpProgramAction[] = [];
		const planner = buildProgramTargetPlanner({
			workspace: buildWorkspace(),
			outputDir: 'Generated',
			channel: buildChannel(actions),
			docblockPrefix: ['Generated by WPKernel'],
		});

		planner.queueFiles({
			files: [
				{
					fileName: 'Capability/Capability.php',
					program: [{ nodeType: 'Stmt_Nop', attributes: {} }],
					metadata: { kind: 'capability-helper' },
					docblock: ['Source: demo'],
					uses: ['WP_Error'],
					statements: ['class Capability {}'],
				},
			],
		});

		expect(actions).toHaveLength(1);
		expect(actions[0]).toEqual(
			expect.objectContaining({
				file: '/workspace/Generated/Capability/Capability.php',
				metadata: { kind: 'capability-helper' },
				docblock: ['Generated by WPKernel', 'Source: demo'],
				uses: ['WP_Error'],
				statements: ['class Capability {}'],
			})
		);
	});

	it('allows custom docblock prefixes per queue invocation', () => {
		const actions: PhpProgramAction[] = [];
		const planner = buildProgramTargetPlanner({
			workspace: buildWorkspace(),
			outputDir: 'Generated',
			channel: buildChannel(actions),
		});

		planner.queueFiles({
			files: [
				{
					fileName: 'Rest/BooksController.php',
					program: [{ nodeType: 'Stmt_Nop', attributes: {} }],
					metadata: { kind: 'resource-controller' },
					docblock: ['Source: demo'],
				},
			],
			docblockPrefix: ['Doc header'],
			filter: (file) => file.metadata.kind === 'resource-controller',
		});

		expect(actions).toHaveLength(1);
		expect(actions[0]?.docblock).toEqual(['Doc header', 'Source: demo']);
	});
});

function buildWorkspace() {
	return {
		root: '/workspace',
		cwd: () => '/workspace',
		resolve: (...parts: string[]) =>
			parts.reduce((acc, part) => `${acc}/${part}`, '/workspace'),
		write: async () => {
			throw new Error('write should not be invoked during planning.');
		},
		exists: async () => true,
	};
}

function buildChannel(buffer: PhpProgramAction[]) {
	return {
		queue: (action: PhpProgramAction) => {
			buffer.push(action);
		},
		drain: () => buffer,
		reset: () => {
			buffer.length = 0;
		},
		pending: () => buffer,
	};
}
