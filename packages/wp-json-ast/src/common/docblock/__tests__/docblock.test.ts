import type {
	PhpAstBuilderAdapter,
	PhpDocComment,
} from '@wpkernel/php-json-ast';

import { DEFAULT_DOC_HEADER } from '../../../constants';
import type { ResourceControllerRouteMetadata } from '../../../types';
import {
	appendGeneratedFileDocblock,
	buildDocCommentAttributes,
	buildGeneratedFileDocComment,
	buildPersistenceRegistryDocblock,
	buildCapabilityCallbackDocblock,
	buildCapabilityEnforceDocblock,
	buildRestBaseControllerDocblock,
	buildRestControllerDocblock,
	buildRestIndexDocblock,
} from '..';

describe('common/docblock', () => {
	it('prefixes generated docblocks with the default header', () => {
		const lines: string[] = [];
		const builder = {
			appendDocblock: (line: string) => {
				lines.push(line);
			},
		} as unknown as PhpAstBuilderAdapter;

		appendGeneratedFileDocblock(builder, ['Example file']);

		expect(lines).toEqual([...DEFAULT_DOC_HEADER, 'Example file']);
	});

	it('creates doc comments that include the header and provided lines', () => {
		const docComment = buildGeneratedFileDocComment(['Example file']);

		expect(docComment.text).toContain('AUTO-GENERATED by WPKernel CLI.');
		expect(docComment.text).toContain('Example file');
	});

	it('builds doc comment attributes when at least one line is present', () => {
		const attributes = buildDocCommentAttributes([
			'Summary line',
			undefined,
			'@tag value',
		]);

		expect(attributes).toBeDefined();
		const comments = Array.isArray(attributes?.comments)
			? (attributes.comments as readonly PhpDocComment[])
			: [];

		expect(comments).toHaveLength(1);
		expect(comments[0]?.text).toContain('Summary line');
		expect(comments[0]?.text).toContain('@tag value');
	});

	it('returns undefined doc comment attributes when no lines are provided', () => {
		expect(buildDocCommentAttributes([])).toBeUndefined();
	});

	it('builds REST base controller docblocks', () => {
		expect(
			buildRestBaseControllerDocblock({
				origin: 'my-plugin',
				sanitizedNamespace: 'MyPlugin',
			})
		).toEqual(['Source: my-plugin → resources (namespace: MyPlugin)']);
	});

	it('builds REST controller docblocks with route metadata', () => {
		const routes: ResourceControllerRouteMetadata[] = [
			{ method: 'GET', path: '/items', kind: 'list' },
			{ method: 'POST', path: '/items', kind: 'create' },
		];

		expect(
			buildRestControllerDocblock({
				origin: 'my-plugin',
				resourceName: 'items',
				schemaKey: 'item',
				schemaProvenance: 'schema.json',
				routes,
			})
		).toEqual([
			'Source: my-plugin → resources.items',
			'Schema: item (schema.json)',
			'Route: [GET] /items',
			'Route: [POST] /items',
		]);
	});

	it('builds REST index docblocks', () => {
		expect(buildRestIndexDocblock({ origin: 'my-plugin' })).toEqual([
			'Source: my-plugin → php/index',
		]);
	});

	it('builds capability docblocks', () => {
		expect(buildCapabilityCallbackDocblock()).toEqual([
			'Create a permission callback closure for a capability.',
		]);
		expect(buildCapabilityEnforceDocblock()).toEqual([
			'Evaluate a capability against the current user.',
			'@return bool|WP_Error',
		]);
	});

	it('builds persistence registry docblocks', () => {
		expect(
			buildPersistenceRegistryDocblock({ origin: 'my-plugin' })
		).toEqual([
			'Source: my-plugin → resources (storage + identity metadata)',
		]);
	});
});
