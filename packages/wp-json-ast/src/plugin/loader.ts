import {
	AUTO_GUARD_BEGIN,
	AUTO_GUARD_END,
	DEFAULT_DOC_HEADER,
} from '../constants';
import {
	buildArg,
	buildArray,
	buildArrayItem,
	buildArrayDimFetch,
	type PhpExprArrayItem,
	buildAssign,
	buildBinaryOperation,
	buildBooleanNot,
	buildComment,
	buildContinue,
	buildDeclare,
	buildDeclareItem,
	buildDocComment,
	buildForeach,
	buildFuncCall,
	buildExpressionStatement,
	buildIdentifier,
	buildIfStatement,
	buildMethodCall,
	buildName,
	buildFullyQualifiedName,
	buildNamespace,
	buildNew,
	buildReturn,
	buildScalarInt,
	buildScalarString,
	buildStmtNop,
	buildVariable,
	buildNode,
	buildTernary,
	mergeNodeAttributes,
	type PhpExpr,
	type PhpExprConstFetch,
	type PhpProgram,
	type PhpStmt,
	type PhpStmtElse,
	type PhpStmtFunction,
} from '@wpkernel/php-json-ast';

/**
 * @category WordPress AST
 */
export interface PluginLoaderProgramConfig {
	readonly origin: string;
	readonly namespace: string;
	readonly sanitizedNamespace: string;
	readonly plugin: PluginLoaderMeta;
	readonly phpGeneratedPath: string;
	readonly resourceClassNames: readonly string[];
	readonly ui?: PluginLoaderUiConfig;
}

interface PluginLoaderUiResourceConfig {
	readonly resource: string;
	readonly preferencesKey: string;
	readonly menu?: {
		readonly slug?: string;
		readonly title?: string;
		readonly capability?: string;
		readonly parent?: string;
		readonly position?: number;
	};
}

interface PluginLoaderUiConfig {
	readonly handle: string;
	readonly assetPath: string;
	readonly scriptPath: string;
	readonly localizationObject: string;
	readonly namespace: string;
	readonly resources: readonly PluginLoaderUiResourceConfig[];
}

export interface PluginLoaderMeta {
	readonly name: string;
	readonly description: string;
	readonly version: string;
	readonly requiresAtLeast: string;
	readonly requiresPhp: string;
	readonly textDomain: string;
	readonly author: string;
	readonly authorUri?: string;
	readonly pluginUri?: string;
	readonly license: string;
	readonly licenseUri?: string;
}

/**
 * @param    config
 * @category WordPress AST
 */
export function buildPluginLoaderProgram(
	config: PluginLoaderProgramConfig
): PhpProgram {
	const pluginHeader = buildPluginHeaderStatement(config);
	const strictTypes = buildDeclare([
		buildDeclareItem('strict_types', buildScalarInt(1)),
	]);

	const namespaceStatements = buildNamespaceStatements(config);

	return [pluginHeader, strictTypes, namespaceStatements];
}

function buildNamespaceStatements(config: PluginLoaderProgramConfig): PhpStmt {
	const namespaceNode = buildName(splitNamespace(config.namespace));
	const statements: PhpStmt[] = [];

	statements.push(
		buildStmtNop({
			comments: [
				buildDocComment([
					...DEFAULT_DOC_HEADER,
					`Source: ${config.origin} → plugin/loader`,
				]),
			],
		})
	);
	statements.push(
		buildStmtNop({ comments: [buildComment(`// ${AUTO_GUARD_BEGIN}`)] })
	);
	statements.push(buildAccessGuardStatement());
	statements.push(buildGetControllersFunction(config));
	statements.push(buildRegisterRoutesFunction());

	const registerUiAssetsFunction = buildRegisterUiAssetsFunction(config);
	if (config.ui && !registerUiAssetsFunction) {
		throw new Error(
			'UI config provided but registerUiAssetsFunction was not generated'
		);
	}
	if (registerUiAssetsFunction) {
		statements.push(registerUiAssetsFunction);
	}

	const registerAdminMenuFunction = buildRegisterAdminMenuFunction(config);
	if (registerAdminMenuFunction) {
		statements.push(registerAdminMenuFunction);
		statements.push(buildRenderAdminScreenFunction(config));
	}

	statements.push(buildBootstrapFunction(config));
	statements.push(buildBootstrapInvocation());
	statements.push(
		buildStmtNop({ comments: [buildComment(`// ${AUTO_GUARD_END}`)] })
	);
	statements.push(
		buildStmtNop({
			comments: [
				buildComment(
					'// Custom plugin logic may be added below. This area is left untouched by the generator.'
				),
			],
		})
	);

	return buildNamespace(namespaceNode, statements);
}

function buildPluginHeaderStatement(
	config: PluginLoaderProgramConfig
): PhpStmt {
	const { plugin } = config;
	const packageName = config.namespace.replace(/\\/g, '');
	const lines: string[] = [
		`Plugin Name: ${plugin.name}`,
		`Description: ${plugin.description}`,
		`Version: ${plugin.version}`,
		`Requires at least: ${plugin.requiresAtLeast}`,
		`Requires PHP: ${plugin.requiresPhp}`,
		`Text Domain: ${plugin.textDomain}`,
		`Author: ${plugin.author}`,
	];

	if (plugin.authorUri) {
		lines.push(`Author URI: ${plugin.authorUri}`);
	}

	if (plugin.pluginUri) {
		lines.push(`Plugin URI: ${plugin.pluginUri}`);
	}

	lines.push(`License: ${plugin.license}`);

	if (plugin.licenseUri) {
		lines.push(`License URI: ${plugin.licenseUri}`);
	}

	lines.push(
		'Generated by WPKernel CLI - edits between WPK:BEGIN AUTO and WPK:END AUTO are managed by the generator.',
		`Source: ${config.origin} → plugin/loader`,
		`@package ${packageName}`
	);

	return buildStmtNop({
		comments: [buildDocComment(lines)],
	});
}

function buildAccessGuardStatement(): PhpStmt {
	const definedCall = buildFuncCall(buildName(['defined']), [
		buildArg(buildScalarString('ABSPATH')),
	]);
	const guardCondition = buildBooleanNot(definedCall);
	const exitCall = buildFuncCall(buildName(['exit']));

	return buildIfStatement(guardCondition, [
		buildExpressionStatement(exitCall),
	]);
}

function buildGetControllersFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction {
	const phpGeneratedPath = normaliseRelativeDirectory(
		config.phpGeneratedPath
	);
	const classmapPathSuffix =
		phpGeneratedPath.length > 0
			? `${phpGeneratedPath}/index.php`
			: 'index.php';

	const returnArray = buildArray(
		config.resourceClassNames.map((className) =>
			buildArrayItem(
				buildNew(buildFullyQualifiedName(splitNamespace(className)))
			)
		)
	);

	const fn = buildNodeFunction('get_wpkernel_controllers', {
		returnType: buildIdentifier('array'),
		statements: [
			buildExpressionStatement(
				buildAssign(
					buildVariable('classmapPath'),
					buildBinaryOperation(
						'Concat',
						buildFuncCall(buildName(['plugin_dir_path']), [
							buildArg(buildConstFetchExpression('__FILE__')),
						]),
						buildScalarString(`/${classmapPathSuffix}`)
					)
				)
			),
			buildIfStatement(
				buildFuncCall(buildName(['file_exists']), [
					buildArg(buildVariable('classmapPath')),
				]),
				[
					buildExpressionStatement(
						buildAssign(
							buildVariable('classmap'),
							buildFuncCall(buildName(['require']), [
								buildArg(buildVariable('classmapPath')),
							])
						)
					),
					buildIfStatement(
						buildFuncCall(buildName(['is_array']), [
							buildArg(buildVariable('classmap')),
						]),
						[
							buildForeach(buildVariable('classmap'), {
								keyVar: buildVariable('class'),
								valueVar: buildVariable('path'),
								stmts: [
									buildIfStatement(
										buildBinaryOperation(
											'BooleanAnd',
											buildBooleanNot(
												buildFuncCall(
													buildName(['class_exists']),
													[
														buildArg(
															buildVariable(
																'class'
															)
														),
													]
												)
											),
											buildFuncCall(
												buildName(['file_exists']),
												[
													buildArg(
														buildVariable('path')
													),
												]
											)
										),
										[
											buildExpressionStatement(
												buildFuncCall(
													buildName(['require_once']),
													[
														buildArg(
															buildVariable(
																'path'
															)
														),
													]
												)
											),
										]
									),
								],
							}),
						]
					),
				]
			),
			buildReturn(returnArray),
		],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Retrieve WPKernel REST controllers generated for this plugin.',
				'@return array<int, object>',
			]),
		],
	});
}

function buildRegisterRoutesFunction(): PhpStmtFunction {
	const controllersAssignment = buildExpressionStatement(
		buildAssign(
			buildVariable('controllers'),
			buildFuncCall(buildName(['get_wpkernel_controllers']))
		)
	);

	const methodExistsCall = buildFuncCall(buildName(['method_exists']), [
		buildArg(buildVariable('controller')),
		buildArg(buildScalarString('register_routes')),
	]);

	const guard = buildIfStatement(buildBooleanNot(methodExistsCall), [
		buildContinue(),
	]);

	const registerCall = buildExpressionStatement(
		buildMethodCall(
			buildVariable('controller'),
			buildIdentifier('register_routes')
		)
	);

	const foreachLoop = buildForeach(buildVariable('controllers'), {
		valueVar: buildVariable('controller'),
		stmts: [guard, registerCall],
	});

	const fn = buildNodeFunction('register_wpkernel_routes', {
		returnType: buildIdentifier('void'),
		statements: [controllersAssignment, foreachLoop],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Register WPKernel REST controllers with WordPress.',
			]),
		],
	});
}

function buildRegisterUiAssetsFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction | null {
	const ui = config.ui;
	if (!ui || ui.resources.length === 0) {
		return null;
	}

	const assetPathAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('asset_path'),
			buildBinaryOperation(
				'Concat',
				buildFuncCall(buildName(['plugin_dir_path']), [
					buildArg(buildConstFetchExpression('__FILE__')),
				]),
				buildScalarString(ui.assetPath)
			)
		)
	);

	const guardMissingAsset = buildIfStatement(
		buildBooleanNot(
			buildFuncCall(buildName(['file_exists']), [
				buildArg(buildVariable('asset_path')),
			])
		),
		[buildReturn(null)]
	);

	const assetContentsAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('asset_contents'),
			buildFuncCall(buildName(['file_get_contents']), [
				buildArg(buildVariable('asset_path')),
			])
		)
	);

	const guardUnreadableAsset = buildIfStatement(
		buildBinaryOperation(
			'Identical',
			buildVariable('asset_contents'),
			buildConstFetchExpression('false')
		),
		[buildReturn(null)]
	);

	const decodeAsset = buildExpressionStatement(
		buildAssign(
			buildVariable('asset'),
			buildFuncCall(buildName(['json_decode']), [
				buildArg(buildVariable('asset_contents')),
				buildArg(buildConstFetchExpression('true')),
			])
		)
	);

	const initialiseDependencies = buildExpressionStatement(
		buildAssign(buildVariable('dependencies'), buildArray([]))
	);

	const dependenciesGuard = buildIfStatement(
		buildBinaryOperation(
			'BooleanAnd',
			buildFuncCall(buildName(['is_array']), [
				buildArg(buildVariable('asset')),
			]),
			buildBinaryOperation(
				'BooleanAnd',
				buildFuncCall(buildName(['isset']), [
					buildArg(
						buildArrayDimFetch(
							buildVariable('asset'),
							buildScalarString('dependencies')
						)
					),
				]),
				buildFuncCall(buildName(['is_array']), [
					buildArg(
						buildArrayDimFetch(
							buildVariable('asset'),
							buildScalarString('dependencies')
						)
					),
				])
			)
		),
		[
			buildExpressionStatement(
				buildAssign(
					buildVariable('dependencies'),
					buildArrayDimFetch(
						buildVariable('asset'),
						buildScalarString('dependencies')
					)
				)
			),
		]
	);

	const coreBundlesAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('core_bundles'),
			buildArray([
				buildArrayItem(buildScalarString('element.min.js'), {
					key: buildScalarString('wp-element'),
				}),
				buildArrayItem(buildScalarString('dataviews.min.js'), {
					key: buildScalarString('wp-dataviews'),
				}),
				buildArrayItem(buildScalarString('interactivity.min.js'), {
					key: buildScalarString('wp-interactivity'),
				}),
				buildArrayItem(buildScalarString('private-apis.min.js'), {
					key: buildScalarString('wp-private-apis'),
				}),
			])
		)
	);

	const ensureCoreBundles = buildForeach(buildVariable('core_bundles'), {
		keyVar: buildVariable('handle'),
		valueVar: buildVariable('filename'),
		stmts: [
			buildIfStatement(
				buildBooleanNot(
					buildFuncCall(buildName(['in_array']), [
						buildArg(buildVariable('handle')),
						buildArg(buildVariable('dependencies')),
						buildArg(buildConstFetchExpression('true')),
					])
				),
				[buildContinue()]
			),
			buildIfStatement(
				buildBinaryOperation(
					'BooleanOr',
					buildFuncCall(buildName(['wp_script_is']), [
						buildArg(buildVariable('handle')),
						buildArg(buildScalarString('registered')),
					]),
					buildFuncCall(buildName(['wp_script_is']), [
						buildArg(buildVariable('handle')),
						buildArg(buildScalarString('enqueued')),
					])
				),
				[buildContinue()]
			),
			buildExpressionStatement(
				buildFuncCall(buildName(['wp_register_script']), [
					buildArg(buildVariable('handle')),
					buildArg(
						buildFuncCall(buildName(['includes_url']), [
							buildArg(
								buildBinaryOperation(
									'Concat',
									buildScalarString('js/dist/'),
									buildVariable('filename')
								)
							),
						])
					),
					buildArg(buildArray([])),
					buildArg(
						buildFuncCall(buildName(['get_bloginfo']), [
							buildArg(buildScalarString('version')),
						])
					),
					buildArg(buildConstFetchExpression('true')),
				])
			),
		],
	});

	const initialiseVersion = buildExpressionStatement(
		buildAssign(
			buildVariable('version'),
			buildConstFetchExpression('false')
		)
	);

	const versionGuard = buildIfStatement(
		buildBinaryOperation(
			'BooleanAnd',
			buildFuncCall(buildName(['is_array']), [
				buildArg(buildVariable('asset')),
			]),
			buildFuncCall(buildName(['array_key_exists']), [
				buildArg(buildScalarString('version')),
				buildArg(buildVariable('asset')),
			])
		),
		[
			buildExpressionStatement(
				buildAssign(
					buildVariable('version'),
					buildArrayDimFetch(
						buildVariable('asset'),
						buildScalarString('version')
					)
				)
			),
		]
	);

	const scriptUrlAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('script_url'),
			buildFuncCall(buildName(['plugins_url']), [
				buildArg(buildScalarString(ui.scriptPath)),
				buildArg(buildConstFetchExpression('__FILE__')),
			])
		)
	);

	const registerScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_register_script']), [
			buildArg(buildScalarString(ui.handle)),
			buildArg(buildVariable('script_url')),
			buildArg(buildVariable('dependencies')),
			buildArg(buildVariable('version')),
		])
	);

	const localizationAssign = buildExpressionStatement(
		buildAssign(buildVariable('localization'), buildLocalizationArray(ui))
	);

	const localizeScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_localize_script']), [
			buildArg(buildScalarString(ui.handle)),
			buildArg(buildScalarString(ui.localizationObject)),
			buildArg(buildVariable('localization')),
		])
	);

	const enqueueScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_enqueue_script']), [
			buildArg(buildScalarString(ui.handle)),
		])
	);

	const statements: PhpStmt[] = [
		assetPathAssign,
		guardMissingAsset,
		assetContentsAssign,
		guardUnreadableAsset,
		decodeAsset,
		initialiseDependencies,
		dependenciesGuard,
		coreBundlesAssign,
		ensureCoreBundles,
		initialiseVersion,
		versionGuard,
		scriptUrlAssign,
		registerScript,
		localizationAssign,
		localizeScript,
		enqueueScript,
	];

	const fn = buildNodeFunction('enqueue_wpkernel_ui_assets', {
		returnType: buildIdentifier('void'),
		statements,
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Register and enqueue generated UI assets for DataViews screens.',
			]),
		],
	});
}

function buildRegisterAdminMenuFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction | null {
	const ui = config.ui;
	if (!ui) {
		return null;
	}

	const menuResources = ui.resources.filter((resource) => resource.menu);
	if (menuResources.length === 0) {
		return null;
	}

	const parentsArray = buildArray(
		menuResources
			.filter((resource) => !resource.menu?.parent)
			.map((resource) => {
				const menuArray = buildMenuLocalizationArray(resource.menu!);
				if (!menuArray) {
					throw new Error('Menu config expected but missing');
				}

				return buildArrayItem(menuArray);
			})
	);

	const childrenArray = buildArray(
		menuResources
			.filter((resource) => Boolean(resource.menu?.parent))
			.map((resource) => {
				const menuArray = buildMenuLocalizationArray(resource.menu!);
				if (!menuArray) {
					throw new Error('Menu config expected but missing');
				}

				return buildArrayItem(menuArray);
			})
	);

	const parentsAssign = buildExpressionStatement(
		buildAssign(buildVariable('parent_menus'), parentsArray)
	);

	const childrenAssign = buildExpressionStatement(
		buildAssign(buildVariable('child_menus'), childrenArray)
	);

	const foreachParents = buildForeach(buildVariable('parent_menus'), {
		valueVar: buildVariable('menu'),
		stmts: buildMenuRegistrationStatements(),
	});

	const foreachChildren = buildForeach(buildVariable('child_menus'), {
		valueVar: buildVariable('menu'),
		stmts: buildMenuRegistrationStatements(),
	});

	const fn = buildNodeFunction('register_wpkernel_admin_menu', {
		returnType: buildIdentifier('void'),
		statements: [
			parentsAssign,
			childrenAssign,
			foreachParents,
			foreachChildren,
		],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Register admin menu entries for WPKernel DataViews screens.',
			]),
		],
	});

	function buildMenuRegistrationStatements(): PhpStmt[] {
		const statements: PhpStmt[] = [];

		const slugAssign = buildExpressionStatement(
			buildAssign(
				buildVariable('slug'),
				buildArrayDimFetch(
					buildVariable('menu'),
					buildScalarString('slug')
				)
			)
		);

		const titleAssign = buildExpressionStatement(
			buildAssign(
				buildVariable('title'),
				buildArrayDimFetch(
					buildVariable('menu'),
					buildScalarString('title')
				)
			)
		);

		const capabilityAssign = buildExpressionStatement(
			buildAssign(
				buildVariable('capability'),
				buildConditionalCapability()
			)
		);

		const callbackAssign = buildExpressionStatement(
			buildAssign(
				buildVariable('callback'),
				buildBinaryOperation(
					'Concat',
					buildConstFetchExpression('__NAMESPACE__'),
					buildScalarString('\\render_wpkernel_admin_screen')
				)
			)
		);

		const parentGuard = buildIfStatement(
			buildBinaryOperation(
				'BooleanAnd',
				buildFuncCall(buildName(['isset']), [
					buildArg(
						buildArrayDimFetch(
							buildVariable('menu'),
							buildScalarString('parent')
						)
					),
				]),
				buildArrayDimFetch(
					buildVariable('menu'),
					buildScalarString('parent')
				)
			),
			[buildParentMenuRegistration(), buildContinue()]
		);

		const topLevelMenuRegistration = buildTopLevelMenuRegistration();

		statements.push(
			slugAssign,
			titleAssign,
			capabilityAssign,
			callbackAssign,
			parentGuard,
			topLevelMenuRegistration
		);

		return statements;
	}

	function buildConditionalCapability(): PhpExpr {
		const capabilityFetch = buildArrayDimFetch(
			buildVariable('menu'),
			buildScalarString('capability')
		);

		return buildTernary(
			buildFuncCall(buildName(['isset']), [buildArg(capabilityFetch)]),
			capabilityFetch,
			buildScalarString('manage_options')
		);
	}

	function buildParentMenuRegistration(): PhpStmt {
		const parentFetch = buildArrayDimFetch(
			buildVariable('menu'),
			buildScalarString('parent')
		);

		const args = [
			buildArg(parentFetch),
			buildArg(buildVariable('title')),
			buildArg(buildVariable('title')),
			buildArg(buildVariable('capability')),
			buildArg(buildVariable('slug')),
			buildArg(buildVariable('callback')),
		];

		const positionGuard = buildIfStatement(
			buildFuncCall(buildName(['isset']), [
				buildArg(
					buildArrayDimFetch(
						buildVariable('menu'),
						buildScalarString('position')
					)
				),
			]),
			[
				buildExpressionStatement(
					buildFuncCall(buildName(['add_submenu_page']), [
						...args,
						buildArg(
							buildArrayDimFetch(
								buildVariable('menu'),
								buildScalarString('position')
							)
						),
					])
				),
			],
			{
				elseBranch: buildElseBranch([
					buildExpressionStatement(
						buildFuncCall(buildName(['add_submenu_page']), args)
					),
				]),
			}
		);

		return positionGuard;
	}

	function buildTopLevelMenuRegistration(): PhpStmt {
		const args = [
			buildArg(buildVariable('title')),
			buildArg(buildVariable('title')),
			buildArg(buildVariable('capability')),
			buildArg(buildVariable('slug')),
			buildArg(buildVariable('callback')),
			buildArg(buildScalarString('')),
		];

		const positionGuard = buildIfStatement(
			buildFuncCall(buildName(['isset']), [
				buildArg(
					buildArrayDimFetch(
						buildVariable('menu'),
						buildScalarString('position')
					)
				),
			]),
			[
				buildExpressionStatement(
					buildFuncCall(buildName(['add_menu_page']), [
						...args,
						buildArg(
							buildArrayDimFetch(
								buildVariable('menu'),
								buildScalarString('position')
							)
						),
					])
				),
			],
			{
				elseBranch: buildElseBranch([
					buildExpressionStatement(
						buildFuncCall(buildName(['add_menu_page']), args)
					),
				]),
			}
		);

		return positionGuard;
	}
}

function buildRenderAdminScreenFunction(
	_config: PluginLoaderProgramConfig
): PhpStmtFunction {
	const pageInit = buildExpressionStatement(
		buildAssign(buildVariable('page'), buildScalarString(''))
	);

	const pageGuard = buildIfStatement(
		buildFuncCall(buildName(['isset']), [
			buildArg(
				buildArrayDimFetch(
					buildVariable('_GET'),
					buildScalarString('page')
				)
			),
		]),
		[
			buildExpressionStatement(
				buildAssign(
					buildVariable('page'),
					buildFuncCall(buildName(['sanitize_key']), [
						buildArg(
							buildFuncCall(buildName(['strval']), [
								buildArg(
									buildArrayDimFetch(
										buildVariable('_GET'),
										buildScalarString('page')
									)
								),
							])
						),
					])
				)
			),
		]
	);

	const printScreen = buildExpressionStatement(
		buildFuncCall(buildName(['printf']), [
			buildArg(
				buildScalarString(
					'<div class="wrap"><div id="wpkernel-admin-screen" data-wpkernel-page="%s"></div></div>'
				)
			),
			buildArg(
				buildFuncCall(buildName(['esc_attr']), [
					buildArg(buildVariable('page')),
				])
			),
		])
	);

	const fn = buildNodeFunction('render_wpkernel_admin_screen', {
		returnType: buildIdentifier('void'),
		statements: [pageInit, pageGuard, printScreen],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Render container for WPKernel-admin DataViews screens.',
			]),
		],
	});
}

function buildElseBranch(stmts: PhpStmt[]): PhpStmtElse {
	return buildNode<PhpStmtElse>('Stmt_Else', { stmts });
}

function buildBootstrapFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction {
	const namespaceConst = buildConstFetchExpression('__NAMESPACE__');
	const restCallback = buildBinaryOperation(
		'Concat',
		namespaceConst,
		buildScalarString('\\register_wpkernel_routes')
	);
	const hasAdminMenu = Boolean(
		config.ui?.resources.some((resource) => Boolean(resource.menu))
	);

	const statements: PhpStmt[] = [
		buildExpressionStatement(
			buildFuncCall(buildName(['add_action']), [
				buildArg(buildScalarString('rest_api_init')),
				buildArg(restCallback),
			])
		),
	];

	if (config.ui) {
		const uiCallback = buildBinaryOperation(
			'Concat',
			namespaceConst,
			buildScalarString('\\enqueue_wpkernel_ui_assets')
		);
		statements.push(
			buildExpressionStatement(
				buildFuncCall(buildName(['add_action']), [
					buildArg(buildScalarString('admin_enqueue_scripts')),
					buildArg(uiCallback),
				])
			)
		);
	}

	if (hasAdminMenu) {
		const adminMenuCallback = buildBinaryOperation(
			'Concat',
			namespaceConst,
			buildScalarString('\\register_wpkernel_admin_menu')
		);
		statements.push(
			buildExpressionStatement(
				buildFuncCall(buildName(['add_action']), [
					buildArg(buildScalarString('admin_menu')),
					buildArg(adminMenuCallback),
				])
			)
		);
	}

	const fn = buildNodeFunction('bootstrap_kernel', {
		returnType: buildIdentifier('void'),
		statements,
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Attach wpk hooks required for REST registration.',
			]),
		],
	});
}

function buildBootstrapInvocation(): PhpStmt {
	return buildExpressionStatement(
		buildFuncCall(buildName(['bootstrap_kernel']))
	);
}

function buildLocalizationArray(ui: PluginLoaderUiConfig): PhpExpr {
	const resourceItems: PhpExprArrayItem[] = ui.resources.map((resource) =>
		buildArrayItem(buildResourceLocalizationArray(resource))
	);

	return buildArray([
		buildArrayItem(buildScalarString(ui.namespace), {
			key: buildScalarString('namespace'),
		}),
		buildArrayItem(buildArray(resourceItems), {
			key: buildScalarString('resources'),
		}),
	]);
}

function buildResourceLocalizationArray(
	resource: PluginLoaderUiResourceConfig
): PhpExpr {
	const items: PhpExprArrayItem[] = [
		buildArrayItem(buildScalarString(resource.resource), {
			key: buildScalarString('resource'),
		}),
		buildArrayItem(buildScalarString(resource.preferencesKey), {
			key: buildScalarString('preferencesKey'),
		}),
	];

	if (resource.menu) {
		const menuArray = buildMenuLocalizationArray(resource.menu);
		if (menuArray) {
			items.push(
				buildArrayItem(menuArray, {
					key: buildScalarString('menu'),
				})
			);
		}
	}

	return buildArray(items);
}

function buildMenuLocalizationArray(
	menu: NonNullable<PluginLoaderUiResourceConfig['menu']>
): PhpExpr | null {
	const items: PhpExprArrayItem[] = [];

	if (menu.slug) {
		items.push(
			buildArrayItem(buildScalarString(menu.slug), {
				key: buildScalarString('slug'),
			})
		);
	}

	if (menu.title) {
		items.push(
			buildArrayItem(buildScalarString(menu.title), {
				key: buildScalarString('title'),
			})
		);
	}

	if (menu.capability) {
		items.push(
			buildArrayItem(buildScalarString(menu.capability), {
				key: buildScalarString('capability'),
			})
		);
	}

	if (menu.parent) {
		items.push(
			buildArrayItem(buildScalarString(menu.parent), {
				key: buildScalarString('parent'),
			})
		);
	}

	if (typeof menu.position === 'number') {
		items.push(
			buildArrayItem(buildScalarInt(menu.position), {
				key: buildScalarString('position'),
			})
		);
	}

	if (items.length === 0) {
		return null;
	}

	return buildArray(items);
}

function buildNodeFunction(
	name: string,
	options: {
		readonly returnType: ReturnType<typeof buildIdentifier> | null;
		readonly statements: readonly PhpStmt[];
	}
): PhpStmtFunction {
	return buildNode<PhpStmtFunction>('Stmt_Function', {
		byRef: false,
		name: buildIdentifier(name),
		params: [],
		returnType: options.returnType,
		stmts: [...options.statements],
		attrGroups: [],
		namespacedName: null,
	});
}

function buildConstFetchExpression(name: string): PhpExprConstFetch {
	return buildNode('Expr_ConstFetch', {
		name: buildName([name]),
	});
}

function splitNamespace(value: string): string[] {
	return value.split('\\').filter(Boolean);
}

function normaliseRelativeDirectory(value: string): string {
	const trimmed = value.replace(/^\.?\//, '').replace(/\/+$/, '');
	return trimmed;
}
