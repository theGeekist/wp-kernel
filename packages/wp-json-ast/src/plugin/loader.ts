import {
	AUTO_GUARD_BEGIN,
	AUTO_GUARD_END,
	DEFAULT_DOC_HEADER,
} from '../constants';
import {
	buildArg,
	buildArray,
	buildArrayItem,
	buildArrayDimFetch,
	type PhpExprArrayItem,
	buildAssign,
	buildBinaryOperation,
	buildBooleanNot,
	buildComment,
	buildContinue,
	buildDeclare,
	buildDeclareItem,
	buildDocComment,
	buildForeach,
	buildFuncCall,
	buildExpressionStatement,
	buildIdentifier,
	buildIfStatement,
	buildMethodCall,
	buildName,
	buildFullyQualifiedName,
	buildNamespace,
	buildNew,
	buildReturn,
	buildScalarInt,
	buildScalarString,
	buildStmtNop,
	buildVariable,
	buildNode,
	mergeNodeAttributes,
	type PhpExpr,
	type PhpExprConstFetch,
	type PhpProgram,
	type PhpStmt,
	type PhpStmtFunction,
} from '@wpkernel/php-json-ast';

/**
 * @category WordPress AST
 */
export interface PluginLoaderProgramConfig {
	readonly origin: string;
	readonly namespace: string;
	readonly sanitizedNamespace: string;
	readonly resourceClassNames: readonly string[];
	readonly ui?: PluginLoaderUiConfig;
}

interface PluginLoaderUiResourceConfig {
	readonly resource: string;
	readonly preferencesKey: string;
	readonly menu?: {
		readonly slug?: string;
		readonly title?: string;
		readonly capability?: string;
		readonly parent?: string;
		readonly position?: number;
	};
}

interface PluginLoaderUiConfig {
	readonly handle: string;
	readonly assetPath: string;
	readonly scriptPath: string;
	readonly localizationObject: string;
	readonly namespace: string;
	readonly resources: readonly PluginLoaderUiResourceConfig[];
}

/**
 * @param    config
 * @category WordPress AST
 */
export function buildPluginLoaderProgram(
	config: PluginLoaderProgramConfig
): PhpProgram {
	const pluginHeader = buildPluginHeaderStatement(config);
	const strictTypes = buildDeclare([
		buildDeclareItem('strict_types', buildScalarInt(1)),
	]);

	const namespaceStatements = buildNamespaceStatements(config);

	return [pluginHeader, strictTypes, namespaceStatements];
}

function buildNamespaceStatements(config: PluginLoaderProgramConfig): PhpStmt {
	const namespaceNode = buildName(splitNamespace(config.namespace));
	const statements: PhpStmt[] = [];

	statements.push(
		buildStmtNop({
			comments: [
				buildDocComment([
					...DEFAULT_DOC_HEADER,
					`Source: ${config.origin} → plugin/loader`,
				]),
			],
		})
	);
	statements.push(
		buildStmtNop({ comments: [buildComment(`// ${AUTO_GUARD_BEGIN}`)] })
	);
	statements.push(buildAccessGuardStatement());
	statements.push(buildGetControllersFunction(config));
	statements.push(buildRegisterRoutesFunction());

	const registerUiAssetsFunction = buildRegisterUiAssetsFunction(config);
	if (registerUiAssetsFunction) {
		statements.push(registerUiAssetsFunction);
	}

	statements.push(buildBootstrapFunction(config));
	statements.push(buildBootstrapInvocation());
	statements.push(
		buildStmtNop({ comments: [buildComment(`// ${AUTO_GUARD_END}`)] })
	);

	return buildNamespace(namespaceNode, statements);
}

function buildPluginHeaderStatement(
	config: PluginLoaderProgramConfig
): PhpStmt {
	const title = buildPluginTitle(config.sanitizedNamespace);
	const packageName = config.namespace.replace(/\\/g, '');
	const lines: string[] = [
		`Plugin Name: ${title}`,
		`Description: Bootstrap loader for the ${title} WP Kernel integration.`,
		'Version: 0.1.0',
		'Requires at least: 6.7',
		'Requires PHP: 8.1',
		`Text Domain: ${config.sanitizedNamespace}`,
		'Author: WP Kernel Contributors',
		'Author URI: https://github.com/thegeekist/wp-kernel',
		'License: GPL-2.0-or-later',
		'License URI: https://www.gnu.org/licenses/gpl-2.0.html',
		'Generated by WP Kernel CLI - edits between WPK:BEGIN AUTO and WPK:END AUTO are managed by the generator.',
		`Source: ${config.origin} → plugin/loader`,
		`@package ${packageName}`,
	];

	return buildStmtNop({
		comments: [buildDocComment(lines)],
	});
}

function buildAccessGuardStatement(): PhpStmt {
	const definedCall = buildFuncCall(buildName(['defined']), [
		buildArg(buildScalarString('ABSPATH')),
	]);
	const guardCondition = buildBooleanNot(definedCall);
	const exitCall = buildFuncCall(buildName(['exit']));

	return buildIfStatement(guardCondition, [
		buildExpressionStatement(exitCall),
	]);
}

function buildGetControllersFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction {
	const returnArray = buildArray(
		config.resourceClassNames.map((className) =>
			buildArrayItem(
				buildNew(buildFullyQualifiedName(splitNamespace(className)))
			)
		)
	);

	const returnStatement = buildReturn(returnArray);

	const fn = buildNodeFunction('get_kernel_controllers', {
		returnType: buildIdentifier('array'),
		statements: [returnStatement],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Retrieve WP Kernel REST controllers generated for this plugin.',
				'@return array<int, object>',
			]),
		],
	});
}

function buildRegisterRoutesFunction(): PhpStmtFunction {
	const controllersAssignment = buildExpressionStatement(
		buildAssign(
			buildVariable('controllers'),
			buildFuncCall(buildName(['get_kernel_controllers']))
		)
	);

	const methodExistsCall = buildFuncCall(buildName(['method_exists']), [
		buildArg(buildVariable('controller')),
		buildArg(buildScalarString('register_routes')),
	]);

	const guard = buildIfStatement(buildBooleanNot(methodExistsCall), [
		buildContinue(),
	]);

	const registerCall = buildExpressionStatement(
		buildMethodCall(
			buildVariable('controller'),
			buildIdentifier('register_routes')
		)
	);

	const foreachLoop = buildForeach(buildVariable('controllers'), {
		valueVar: buildVariable('controller'),
		stmts: [guard, registerCall],
	});

	const fn = buildNodeFunction('register_kernel_routes', {
		returnType: buildIdentifier('void'),
		statements: [controllersAssignment, foreachLoop],
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Register WP Kernel REST controllers with WordPress.',
			]),
		],
	});
}

function buildRegisterUiAssetsFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction | null {
	const ui = config.ui;
	if (!ui || ui.resources.length === 0) {
		return null;
	}

	const assetPathAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('asset_path'),
			buildBinaryOperation(
				'Concat',
				buildFuncCall(buildName(['plugin_dir_path']), [
					buildArg(buildConstFetchExpression('__FILE__')),
				]),
				buildScalarString(ui.assetPath)
			)
		)
	);

	const guardMissingAsset = buildIfStatement(
		buildBooleanNot(
			buildFuncCall(buildName(['file_exists']), [
				buildArg(buildVariable('asset_path')),
			])
		),
		[buildReturn(null)]
	);

	const assetContentsAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('asset_contents'),
			buildFuncCall(buildName(['file_get_contents']), [
				buildArg(buildVariable('asset_path')),
			])
		)
	);

	const guardUnreadableAsset = buildIfStatement(
		buildBinaryOperation(
			'Identical',
			buildVariable('asset_contents'),
			buildConstFetchExpression('false')
		),
		[buildReturn(null)]
	);

	const decodeAsset = buildExpressionStatement(
		buildAssign(
			buildVariable('asset'),
			buildFuncCall(buildName(['json_decode']), [
				buildArg(buildVariable('asset_contents')),
				buildArg(buildConstFetchExpression('true')),
			])
		)
	);

	const initialiseDependencies = buildExpressionStatement(
		buildAssign(buildVariable('dependencies'), buildArray([]))
	);

	const dependenciesGuard = buildIfStatement(
		buildBinaryOperation(
			'BooleanAnd',
			buildFuncCall(buildName(['is_array']), [
				buildArg(buildVariable('asset')),
			]),
			buildBinaryOperation(
				'BooleanAnd',
				buildFuncCall(buildName(['isset']), [
					buildArg(
						buildArrayDimFetch(
							buildVariable('asset'),
							buildScalarString('dependencies')
						)
					),
				]),
				buildFuncCall(buildName(['is_array']), [
					buildArg(
						buildArrayDimFetch(
							buildVariable('asset'),
							buildScalarString('dependencies')
						)
					),
				])
			)
		),
		[
			buildExpressionStatement(
				buildAssign(
					buildVariable('dependencies'),
					buildArrayDimFetch(
						buildVariable('asset'),
						buildScalarString('dependencies')
					)
				)
			),
		]
	);

	const initialiseVersion = buildExpressionStatement(
		buildAssign(
			buildVariable('version'),
			buildConstFetchExpression('false')
		)
	);

	const versionGuard = buildIfStatement(
		buildBinaryOperation(
			'BooleanAnd',
			buildFuncCall(buildName(['is_array']), [
				buildArg(buildVariable('asset')),
			]),
			buildFuncCall(buildName(['array_key_exists']), [
				buildArg(buildScalarString('version')),
				buildArg(buildVariable('asset')),
			])
		),
		[
			buildExpressionStatement(
				buildAssign(
					buildVariable('version'),
					buildArrayDimFetch(
						buildVariable('asset'),
						buildScalarString('version')
					)
				)
			),
		]
	);

	const scriptUrlAssign = buildExpressionStatement(
		buildAssign(
			buildVariable('script_url'),
			buildFuncCall(buildName(['plugins_url']), [
				buildArg(buildScalarString(ui.scriptPath)),
				buildArg(buildConstFetchExpression('__FILE__')),
			])
		)
	);

	const registerScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_register_script']), [
			buildArg(buildScalarString(ui.handle)),
			buildArg(buildVariable('script_url')),
			buildArg(buildVariable('dependencies')),
			buildArg(buildVariable('version')),
		])
	);

	const localizationAssign = buildExpressionStatement(
		buildAssign(buildVariable('localization'), buildLocalizationArray(ui))
	);

	const localizeScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_localize_script']), [
			buildArg(buildScalarString(ui.handle)),
			buildArg(buildScalarString(ui.localizationObject)),
			buildArg(buildVariable('localization')),
		])
	);

	const enqueueScript = buildExpressionStatement(
		buildFuncCall(buildName(['wp_enqueue_script']), [
			buildArg(buildScalarString(ui.handle)),
		])
	);

	const statements: PhpStmt[] = [
		assetPathAssign,
		guardMissingAsset,
		assetContentsAssign,
		guardUnreadableAsset,
		decodeAsset,
		initialiseDependencies,
		dependenciesGuard,
		initialiseVersion,
		versionGuard,
		scriptUrlAssign,
		registerScript,
		localizationAssign,
		localizeScript,
		enqueueScript,
	];

	const fn = buildNodeFunction('enqueue_kernel_ui_assets', {
		returnType: buildIdentifier('void'),
		statements,
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Register and enqueue generated UI assets for DataViews screens.',
			]),
		],
	});
}

function buildBootstrapFunction(
	config: PluginLoaderProgramConfig
): PhpStmtFunction {
	const namespaceConst = buildConstFetchExpression('__NAMESPACE__');
	const restCallback = buildBinaryOperation(
		'Concat',
		namespaceConst,
		buildScalarString('\\register_kernel_routes')
	);

	const statements: PhpStmt[] = [
		buildExpressionStatement(
			buildFuncCall(buildName(['add_action']), [
				buildArg(buildScalarString('rest_api_init')),
				buildArg(restCallback),
			])
		),
	];

	if (config.ui) {
		const uiCallback = buildBinaryOperation(
			'Concat',
			namespaceConst,
			buildScalarString('\\enqueue_kernel_ui_assets')
		);
		statements.push(
			buildExpressionStatement(
				buildFuncCall(buildName(['add_action']), [
					buildArg(buildScalarString('admin_enqueue_scripts')),
					buildArg(uiCallback),
				])
			)
		);
	}

	const fn = buildNodeFunction('bootstrap_kernel', {
		returnType: buildIdentifier('void'),
		statements,
	});

	return mergeNodeAttributes(fn, {
		comments: [
			buildDocComment([
				'Attach kernel hooks required for REST registration.',
			]),
		],
	});
}

function buildBootstrapInvocation(): PhpStmt {
	return buildExpressionStatement(
		buildFuncCall(buildName(['bootstrap_kernel']))
	);
}

function buildLocalizationArray(ui: PluginLoaderUiConfig): PhpExpr {
	const resourceItems: PhpExprArrayItem[] = ui.resources.map((resource) =>
		buildArrayItem(buildResourceLocalizationArray(resource))
	);

	return buildArray([
		buildArrayItem(buildScalarString(ui.namespace), {
			key: buildScalarString('namespace'),
		}),
		buildArrayItem(buildArray(resourceItems), {
			key: buildScalarString('resources'),
		}),
	]);
}

function buildResourceLocalizationArray(
	resource: PluginLoaderUiResourceConfig
): PhpExpr {
	const items: PhpExprArrayItem[] = [
		buildArrayItem(buildScalarString(resource.resource), {
			key: buildScalarString('resource'),
		}),
		buildArrayItem(buildScalarString(resource.preferencesKey), {
			key: buildScalarString('preferencesKey'),
		}),
	];

	if (resource.menu) {
		const menuArray = buildMenuLocalizationArray(resource.menu);
		if (menuArray) {
			items.push(
				buildArrayItem(menuArray, {
					key: buildScalarString('menu'),
				})
			);
		}
	}

	return buildArray(items);
}

function buildMenuLocalizationArray(
	menu: NonNullable<PluginLoaderUiResourceConfig['menu']>
): PhpExpr | null {
	const items: PhpExprArrayItem[] = [];

	if (menu.slug) {
		items.push(
			buildArrayItem(buildScalarString(menu.slug), {
				key: buildScalarString('slug'),
			})
		);
	}

	if (menu.title) {
		items.push(
			buildArrayItem(buildScalarString(menu.title), {
				key: buildScalarString('title'),
			})
		);
	}

	if (menu.capability) {
		items.push(
			buildArrayItem(buildScalarString(menu.capability), {
				key: buildScalarString('capability'),
			})
		);
	}

	if (menu.parent) {
		items.push(
			buildArrayItem(buildScalarString(menu.parent), {
				key: buildScalarString('parent'),
			})
		);
	}

	if (typeof menu.position === 'number') {
		items.push(
			buildArrayItem(buildScalarInt(menu.position), {
				key: buildScalarString('position'),
			})
		);
	}

	if (items.length === 0) {
		return null;
	}

	return buildArray(items);
}

function buildNodeFunction(
	name: string,
	options: {
		readonly returnType: ReturnType<typeof buildIdentifier> | null;
		readonly statements: readonly PhpStmt[];
	}
): PhpStmtFunction {
	return buildNode<PhpStmtFunction>('Stmt_Function', {
		byRef: false,
		name: buildIdentifier(name),
		params: [],
		returnType: options.returnType,
		stmts: [...options.statements],
		attrGroups: [],
		namespacedName: null,
	});
}

function buildConstFetchExpression(name: string): PhpExprConstFetch {
	return buildNode('Expr_ConstFetch', {
		name: buildName([name]),
	});
}

function splitNamespace(value: string): string[] {
	return value.split('\\').filter(Boolean);
}

function buildPluginTitle(sanitized: string): string {
	if (!sanitized) {
		return 'WP Kernel Plugin';
	}

	return sanitized
		.split('-')
		.filter(Boolean)
		.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
		.join(' ');
}
