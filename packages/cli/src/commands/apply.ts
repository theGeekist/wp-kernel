import { Command, Option } from 'clipanion';
import { type WPKExitCode } from '@wpkernel/core/contracts';
import { determineExitCode, reportFailure } from './apply/errors';
import { buildReporterNamespace } from './apply/constants';
import { mergeDependencies } from './apply/dependencies';
import { formatManifest } from './apply/io';
import { initialiseWorkspace } from './apply/workspace';
import {
	executeApply,
	handleCompletion,
	previewPatches,
	processPreviewStage,
} from './apply/workflow';
import { handleFailureLog } from './apply/logging';
import { resolveFlags } from './apply/flags';
import type {
	ApplyCommandConstructor,
	ApplyCommandInstance,
	BuildApplyCommandOptions,
	PatchManifest,
	PatchManifestSummary,
	PatchRecord,
} from './apply/types';
import type { Workspace } from '../next/workspace';

export { APPLY_LOG_PATH, PATCH_MANIFEST_PATH } from './apply/constants';
export { createBackups } from './apply/backups';
export { appendApplyLog } from './apply/logging';
export { buildBuilderOutput, readManifest, formatManifest } from './apply/io';
export { ensureGitRepository, resolveWorkspaceRoot } from './apply/workspace';
export type {
	ApplyCommandConstructor,
	ApplyCommandInstance,
	ApplyFlags,
	ApplyLogEntry,
	ApplyLogStatus,
	CreateBackupsOptions,
	BuildApplyCommandOptions,
	PatchManifest,
	PatchManifestSummary,
	PatchRecord,
	PatchStatus,
	PreviewResult,
} from './apply/types';

function withCommandState(
	command: ApplyCommandInstance,
	manifest: PatchManifest | null
): void {
	if (!manifest) {
		command.manifest = null;
		command.summary = null;
		command.records = [];
		return;
	}

	command.manifest = manifest;
	command.summary = manifest.summary;
	command.records = manifest.records;
}

export function buildApplyCommand(
	options: BuildApplyCommandOptions = {}
): ApplyCommandConstructor {
	const dependencies = mergeDependencies(options);

	class NextApplyCommand extends Command {
		static override paths = [['apply']];

		static override usage = Command.Usage({
			description:
				'Apply pending workspace patches generated by the next pipeline.',
			examples: [['Apply pending patches', 'wpk apply']],
		});

		yes = Option.Boolean('--yes', false);
		backup = Option.Boolean('--backup', false);
		force = Option.Boolean('--force', false);

		public summary: PatchManifestSummary | null = null;
		public records: PatchRecord[] = [];
		public manifest: PatchManifest | null = null;

		override async execute(): Promise<WPKExitCode> {
			let workspace: Workspace | null = null;
			const flags = resolveFlags(this);
			const reporter = dependencies.buildReporter({
				namespace: buildReporterNamespace(),
				level: 'info',
				enabled: process.env.NODE_ENV !== 'test',
			});

			try {
				const { workspace: activeWorkspace, loaded } =
					await initialiseWorkspace({ dependencies });
				workspace = activeWorkspace;

				const preview = await previewPatches({
					dependencies,
					workspace: activeWorkspace,
					loaded,
				});

				const previewExit = await processPreviewStage({
					command: this,
					workspace: activeWorkspace,
					dependencies,
					reporter,
					flags,
					preview,
				});

				if (previewExit !== null) {
					return previewExit;
				}

				if (flags.backup) {
					await dependencies.createBackups({
						workspace: activeWorkspace,
						manifest: preview.workspaceManifest,
						reporter,
					});
				}

				const manifest = await executeApply({
					dependencies,
					workspace: activeWorkspace,
					loaded,
					reporter,
				});

				withCommandState(this, manifest);
				this.context.stdout.write(formatManifest(manifest));

				return handleCompletion({
					workspace: activeWorkspace,
					dependencies,
					reporter,
					manifest,
					flags,
				});
			} catch (error) {
				withCommandState(this, null);
				reportFailure(
					reporter,
					'Failed to apply workspace patches.',
					error
				);
				const exitCode = determineExitCode(error);

				if (workspace) {
					await handleFailureLog({
						workspace,
						dependencies,
						flags,
						exitCode,
						error,
					});
				}

				return exitCode;
			}
		}
	}

	return NextApplyCommand as ApplyCommandConstructor;
}

export const NextApplyCommand = buildApplyCommand();