import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs/promises';
import { Writable } from 'node:stream';
import type { Command } from 'clipanion';
import { GenerateCommand } from '../generate';
import * as printers from '../../printers';
import * as ir from '../../ir';
import { KernelError } from '@geekist/wp-kernel';

jest.mock('json-schema-to-typescript', () => ({
	compile: jest.fn(async () => 'export interface Schema {}\n'),
}));

jest.mock('prettier', () => ({
	format: jest.fn(async (contents: string) => contents),
}));

jest.mock('@prettier/plugin-php', () => ({}));

const TMP_PREFIX = path.join(os.tmpdir(), 'wpk-generate-command-');

describe('GenerateCommand', () => {
	it('writes generated artifacts and records summary', async () => {
		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const exitCode = await command.execute();

			expect(exitCode).toBe(0);
			expect(command.summary?.counts.written).toBeGreaterThan(0);

			const baseControllerPath = path.join(
				workspace,
				'.generated/php/Rest/BaseController.php'
			);
			const baseController = await fs.readFile(
				baseControllerPath,
				'utf8'
			);
			expect(baseController).toContain(
				'AUTO-GENERATED by WP Kernel CLI.'
			);
		});
	});

	it('skips unchanged files on subsequent runs', async () => {
		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const firstExitCode = await command.execute();
			expect(firstExitCode).toBe(0);

			const baseControllerPath = path.join(
				workspace,
				'.generated/php/Rest/BaseController.php'
			);
			const initialStat = await fs.stat(baseControllerPath);

			await new Promise((resolve) => setTimeout(resolve, 10));

			const secondCommand = createCommand(workspace);
			const exitCode = await secondCommand.execute();
			expect(exitCode).toBe(0);
			expect(secondCommand.summary?.counts.unchanged).toBeGreaterThan(0);

			const secondStat = await fs.stat(baseControllerPath);
			expect(secondStat.mtimeMs).toBe(initialStat.mtimeMs);
		});
	});

	it('performs dry-run without writing artifacts', async () => {
		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const firstExitCode = await command.execute();
			expect(firstExitCode).toBe(0);

			const baseControllerPath = path.join(
				workspace,
				'.generated/php/Rest/BaseController.php'
			);
			const baseline = await fs.readFile(baseControllerPath, 'utf8');

			const schemaPath = path.join(workspace, 'schemas/job.schema.json');
			const schema = JSON.parse(await fs.readFile(schemaPath, 'utf8'));
			schema.properties.title.description = 'Updated title';
			await fs.writeFile(
				schemaPath,
				JSON.stringify(schema, null, 2),
				'utf8'
			);

			const dryRunCommand = createCommand(workspace);
			dryRunCommand.dryRun = true;
			const exitCode = await dryRunCommand.execute();

			expect(exitCode).toBe(0);
			expect(dryRunCommand.summary?.dryRun).toBe(true);
			expect(dryRunCommand.summary?.counts.skipped).toBeGreaterThan(0);

			const afterDryRun = await fs.readFile(baseControllerPath, 'utf8');
			expect(afterDryRun).toBe(baseline);
		});
	});

	it('returns exit code 1 when validation fails', async () => {
		await withWorkspace(async (workspace) => {
			await writeComposerJson(workspace, {
				autoload: { 'psr-4': { 'Demo\\Plugin\\': 'src/' } },
			});

			const command = createCommand(workspace);
			const exitCode = await command.execute();
			expect(exitCode).toBe(1);
		});
	});

	it('returns exit code 1 when IR builder raises developer error', async () => {
		const buildSpy = jest.spyOn(ir, 'buildIr').mockRejectedValueOnce(
			new KernelError('DeveloperError', {
				message: 'adapter mismatch',
			})
		);

		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const exitCode = await command.execute();
			expect(exitCode).toBe(1);
		});

		buildSpy.mockRestore();
	});

	it('returns exit code 3 when adapter throws', async () => {
		await withWorkspace(
			async (workspace) => {
				await writeKernelConfig(workspace, {
					phpAdapter: '() => { throw new Error("adapter boom"); }',
				});

				const command = createCommand(workspace);
				const exitCode = await command.execute();
				expect(exitCode).toBe(3);
			},
			{ withDefaultConfig: false }
		);
	});

	it('returns exit code 2 when printers fail', async () => {
		const emitSpy = jest
			.spyOn(printers, 'emitGeneratedArtifacts')
			.mockRejectedValue(new Error('printer boom'));

		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const exitCode = await command.execute();
			expect(exitCode).toBe(2);
		});

		emitSpy.mockRestore();
	});

	it('serialises non-error printer failures', async () => {
		const emitSpy = jest
			.spyOn(printers, 'emitGeneratedArtifacts')
			.mockRejectedValue('printer boom');

		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			const exitCode = await command.execute();
			expect(exitCode).toBe(2);
		});

		emitSpy.mockRestore();
	});

	it('prints verbose summaries with file listings', async () => {
		await withWorkspace(async (workspace) => {
			const command = createCommand(workspace);
			command.verbose = true;

			const exitCode = await command.execute();
			expect(exitCode).toBe(0);

			const stdout = (command.context.stdout as MemoryStream).toString();
			expect(stdout).toContain('files:');
		});
	});

	it('treats falsy adapters as undefined', async () => {
		await withWorkspace(
			async (workspace) => {
				await writeKernelConfig(workspace, {
					phpAdapter: '() => null',
				});

				const command = createCommand(workspace);
				const exitCode = await command.execute();
				expect(exitCode).toBe(0);
			},
			{ withDefaultConfig: false }
		);
	});
});

async function withWorkspace(
	run: (workspace: string) => Promise<void>,
	options: { withDefaultConfig?: boolean } = {}
): Promise<void> {
	const workspace = await fs.mkdtemp(TMP_PREFIX);
	const { withDefaultConfig = true } = options;

	try {
		await fs.mkdir(path.join(workspace, 'schemas'), { recursive: true });

		await writeComposerJson(workspace);

		if (withDefaultConfig) {
			await writeKernelConfig(workspace);
		}

		await writeSchema(workspace);

		const originalCwd = process.cwd();
		process.chdir(workspace);
		try {
			await run(workspace);
		} finally {
			process.chdir(originalCwd);
		}
	} finally {
		await fs.rm(workspace, { recursive: true, force: true });
	}
}

function createCommand(workspace: string): GenerateCommand {
	const command = new GenerateCommand();
	const stdout = new MemoryStream();
	const stderr = new MemoryStream();

	command.context = {
		stdout,
		stderr,
		stdin: process.stdin,
		env: process.env,
		cwd: () => workspace,
	} as Command.Context;

	command.dryRun = false;
	command.verbose = false;

	return command;
}

async function writeKernelConfig(
	workspace: string,
	options: { phpAdapter?: string } = {}
): Promise<void> {
	const { phpAdapter } = options;
	const adapterSnippet = phpAdapter
		? `,
        adapters: {
                php: ${phpAdapter},
        }`
		: '';

	const config = `module.exports = {
        version: 1,
        namespace: 'demo-plugin',
        schemas: {
                job: {
                        path: './schemas/job.schema.json',
                        generated: { types: './.generated/types/job.d.ts' },
                },
        },
        resources: {
                job: {
                        name: 'job',
                        schema: 'job',
                        routes: {
                                list: { method: 'GET', path: '/jobs' },
                                get: { method: 'GET', path: '/jobs/:id' },
                                create: { method: 'POST', path: '/jobs' },
                        },
                        cacheKeys: {
                                list: () => ['job', 'list'],
                                get: (id) => ['job', 'get', id ?? null],
                        },
                        identity: { type: 'number', param: 'id' },
                        storage: { mode: 'wp-post', postType: 'job' },
                },
        }${adapterSnippet},
};
`;

	await fs.writeFile(
		path.join(workspace, 'kernel.config.js'),
		config,
		'utf8'
	);
}

async function writeComposerJson(
	workspace: string,
	overrides: Record<string, unknown> = {}
): Promise<void> {
	const composer = {
		name: 'demo/plugin',
		autoload: {
			'psr-4': {
				'Demo\\Plugin\\': 'inc/',
			},
		},
		...overrides,
	};

	await fs.writeFile(
		path.join(workspace, 'composer.json'),
		JSON.stringify(composer, null, 2),
		'utf8'
	);
}

async function writeSchema(workspace: string): Promise<void> {
	const schema = {
		$schema: 'https://json-schema.org/draft/2020-12/schema',
		type: 'object',
		required: ['id'],
		properties: {
			id: { type: 'integer', description: 'Identifier' },
			title: { type: 'string', description: 'Title' },
		},
	};

	await fs.writeFile(
		path.join(workspace, 'schemas/job.schema.json'),
		JSON.stringify(schema, null, 2),
		'utf8'
	);
}

class MemoryStream extends Writable {
	private readonly chunks: string[] = [];

	override _write(
		chunk: string | Buffer,
		_encoding: BufferEncoding,
		callback: (error?: Error | null) => void
	): void {
		this.chunks.push(chunk.toString());
		callback();
	}

	toString(): string {
		return this.chunks.join('');
	}
}
