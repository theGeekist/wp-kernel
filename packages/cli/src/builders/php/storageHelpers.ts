import { createHelper } from '../../runtime';
import type {
	BuilderApplyOptions,
	BuilderHelper,
	BuilderNext,
	PipelineContext,
} from '../../runtime/types';
import type {
	RestControllerRouteHandlers,
	RestControllerRouteOptionHandlers,
	TransientStorageArtifacts,
} from '@wpkernel/wp-json-ast';
import {
	buildTransientStorageArtifacts,
	buildWpOptionStorageArtifacts,
	buildWpTaxonomyHelperArtifacts,
	buildWpTaxonomyQueryRouteBundle,
	resolveTransientKey,
	ensureWpTaxonomyStorage,
} from '@wpkernel/wp-json-ast';
import type { IRv1 } from '../../ir/publicTypes';
import { resolveIdentityConfig } from './identity';
import { makeErrorCodeFactory, toPascalCase } from './utils';
import { ensureWpOptionStorage } from './shared';

/**
 * Represents the artifacts generated by the WP Option storage helper.
 *
 * @category PHP Builder
 */
export interface WpOptionStorageHelperArtifacts {
	/** The helper methods generated for WP Option storage. */
	readonly helperMethods: ReturnType<
		typeof buildWpOptionStorageArtifacts
	>['helperMethods'];
	/** The route handlers generated for WP Option storage. */
	readonly routeHandlers: RestControllerRouteOptionHandlers;
}

/**
 * Represents the artifacts generated by the WP Taxonomy storage helper.
 *
 * @category PHP Builder
 */
export interface WpTaxonomyStorageHelperArtifacts {
	/** The helper methods generated for WP Taxonomy storage. */
	readonly helperMethods: ReturnType<
		typeof buildWpTaxonomyHelperArtifacts
	>['helperMethods'];
	/** The helper signatures generated for WP Taxonomy storage. */
	readonly helperSignatures: ReturnType<
		typeof buildWpTaxonomyHelperArtifacts
	>['helperSignatures'];
	/** The route handlers generated for WP Taxonomy storage. */
	readonly routeHandlers: RestControllerRouteHandlers;
}

/**
 * Represents the state managed by the resource storage helpers.
 *
 * This state stores the generated artifacts for different storage modes
 * (transient, wp-option, wp-taxonomy) keyed by resource name.
 *
 * @category PHP Builder
 */
export interface ResourceStorageHelperState {
	/** A map of resource names to their transient storage artifacts. */
	readonly transient: Map<string, TransientStorageArtifacts>;
	/** A map of resource names to their WP Option storage artifacts. */
	readonly wpOption: Map<string, WpOptionStorageHelperArtifacts>;
	/** A map of resource names to their WP Taxonomy storage artifacts. */
	readonly wpTaxonomy: Map<string, WpTaxonomyStorageHelperArtifacts>;
}

const RESOURCE_STORAGE_HELPERS_SYMBOL = Symbol(
	'@wpkernel/cli/resource/storageHelpers'
);

interface ResourceStorageHelperHost {
	[RESOURCE_STORAGE_HELPERS_SYMBOL]?: ResourceStorageHelperState;
}

/**
 * Retrieves the singleton state object for resource storage helpers from the pipeline context.
 *
 * If the state object does not exist in the context, it is initialized.
 *
 * @category PHP Builder
 * @param    context - The current pipeline context.
 * @returns The `ResourceStorageHelperState` instance.
 */
export function getResourceStorageHelperState(
	context: PipelineContext
): ResourceStorageHelperState {
	const host = context as ResourceStorageHelperHost;
	if (!host[RESOURCE_STORAGE_HELPERS_SYMBOL]) {
		host[RESOURCE_STORAGE_HELPERS_SYMBOL] = {
			transient: new Map(),
			wpOption: new Map(),
			wpTaxonomy: new Map(),
		} satisfies ResourceStorageHelperState;
	}

	return host[RESOURCE_STORAGE_HELPERS_SYMBOL]!;
}

/**
 * Creates a PHP builder helper for transient storage.
 *
 * This helper processes resources configured to use 'transient' storage mode
 * and populates the `ResourceStorageHelperState` with the necessary artifacts
 * for generating transient-based CRUD operations.
 *
 * @category PHP Builder
 * @returns A `BuilderHelper` instance for transient storage.
 */
export function createPhpTransientStorageHelper(): BuilderHelper {
	return createHelper({
		key: 'builder.generate.php.controller.resources.storage.transient',
		kind: 'builder',
		async apply(options: BuilderApplyOptions, next?: BuilderNext) {
			const { input } = options;
			if (input.phase !== 'generate' || !input.ir) {
				await next?.();
				return;
			}

			const state = getResourceStorageHelperState(options.context);
			state.transient.clear();

			populateTransientArtifacts({
				ir: input.ir,
				state,
			});

			await next?.();
		},
	});
}

/**
 * Creates a PHP builder helper for WP Option storage.
 *
 * This helper processes resources configured to use 'wp-option' storage mode
 * and populates the `ResourceStorageHelperState` with the necessary artifacts
 * for generating WP Option-based CRUD operations.
 *
 * @category PHP Builder
 * @returns A `BuilderHelper` instance for WP Option storage.
 */
export function createPhpWpOptionStorageHelper(): BuilderHelper {
	return createHelper({
		key: 'builder.generate.php.controller.resources.storage.wpOption',
		kind: 'builder',
		async apply(options: BuilderApplyOptions, next?: BuilderNext) {
			const { input } = options;
			if (input.phase !== 'generate' || !input.ir) {
				await next?.();
				return;
			}

			const state = getResourceStorageHelperState(options.context);
			state.wpOption.clear();

			populateWpOptionArtifacts({
				ir: input.ir,
				state,
			});

			await next?.();
		},
	});
}

/**
 * Creates a PHP builder helper for WP Taxonomy storage.
 *
 * This helper processes resources configured to use 'wp-taxonomy' storage mode
 * and populates the `ResourceStorageHelperState` with the necessary artifacts
 * for generating WP Taxonomy-based CRUD operations.
 *
 * @category PHP Builder
 * @returns A `BuilderHelper` instance for WP Taxonomy storage.
 */
export function createPhpWpTaxonomyStorageHelper(): BuilderHelper {
	return createHelper({
		key: 'builder.generate.php.controller.resources.storage.wpTaxonomy',
		kind: 'builder',
		async apply(options: BuilderApplyOptions, next?: BuilderNext) {
			const { input } = options;
			if (input.phase !== 'generate' || !input.ir) {
				await next?.();
				return;
			}

			const state = getResourceStorageHelperState(options.context);
			state.wpTaxonomy.clear();

			populateWpTaxonomyArtifacts({
				ir: input.ir,
				state,
			});

			await next?.();
		},
	});
}

interface PopulateArtifactsBaseOptions {
	readonly ir: IRv1;
	readonly state: ResourceStorageHelperState;
}

function populateTransientArtifacts(
	options: PopulateArtifactsBaseOptions
): void {
	for (const resource of options.ir.resources) {
		if (resource.storage?.mode !== 'transient') {
			continue;
		}

		const identity = resolveIdentityConfig(resource);
		const pascalName = toPascalCase(resource.name);
		const errorCodeFactory = makeErrorCodeFactory(resource.name);
		const key = resolveTransientKey({
			resourceName: resource.name,
			namespace:
				options.ir.meta.sanitizedNamespace ??
				options.ir.meta.namespace ??
				'',
		});

		const artifacts = buildTransientStorageArtifacts({
			pascalName,
			key,
			identity,
			cacheSegments: resource.cacheKeys.get.segments,
			errorCodeFactory,
		});

		options.state.transient.set(resource.name, artifacts);
	}
}

function populateWpOptionArtifacts(
	options: PopulateArtifactsBaseOptions
): void {
	for (const resource of options.ir.resources) {
		if (resource.storage?.mode !== 'wp-option') {
			continue;
		}

		const storage = ensureWpOptionStorage(resource);
		const pascalName = toPascalCase(resource.name);
		const errorCodeFactory = makeErrorCodeFactory(resource.name);
		const artifacts = buildWpOptionStorageArtifacts({
			pascalName,
			optionName: storage.option,
			errorCodeFactory,
		});

		options.state.wpOption.set(resource.name, {
			helperMethods: artifacts.helperMethods,
			routeHandlers: artifacts.routeHandlers,
		});
	}
}

function populateWpTaxonomyArtifacts(
	options: PopulateArtifactsBaseOptions
): void {
	for (const resource of options.ir.resources) {
		if (resource.storage?.mode !== 'wp-taxonomy') {
			continue;
		}

		const storage = ensureWpTaxonomyStorage(resource.storage, {
			resourceName: resource.name,
		});
		const identity = resolveIdentityConfig(resource);
		const pascalName = toPascalCase(resource.name);
		const errorCodeFactory = makeErrorCodeFactory(resource.name);

		const helperArtifacts = buildWpTaxonomyHelperArtifacts({
			pascalName,
			storage,
			identity,
			errorCodeFactory,
		});
		const queryBundle = buildWpTaxonomyQueryRouteBundle({
			pascalName,
			storage,
			identity,
			errorCodeFactory,
			resourceName: resource.name,
		});

		options.state.wpTaxonomy.set(resource.name, {
			helperMethods: helperArtifacts.helperMethods,
			helperSignatures: helperArtifacts.helperSignatures,
			routeHandlers: queryBundle.routeHandlers,
		});
	}
}
