// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: base-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WP Kernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources (namespace: DemoPlugin)
 */
namespace Demo\\Plugin\\Rest;

// WPK:BEGIN AUTO
abstract class BaseController
{
    public function get_namespace(): string
    {
        return 'DemoPlugin';
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: books-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WP Kernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.books
 * Schema: book (manual)
 * Route: [GET] /kernel/v1/books
 * Route: [GET] /kernel/v1/books/:slug
 * Route: [POST] /kernel/v1/books
 * Route: [PUT] /kernel/v1/books/:slug
 * Route: [DELETE] /kernel/v1/books/:slug
 */
namespace Demo\\Plugin\\Rest;

use WP_Error;
use WP_Post;
use WP_Query;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
final class BooksController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'books';
    }
    public function get_schema_key(): string
    {
        return 'book';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Handle [GET] /kernel/v1/books.
     * @wp-kernel route-kind list
     */
    public function getKernelV1Books(WP_REST_Request $request)
    {
        $post_type = $this->getBooksPostType();
        $per_page = (int) $request->get_param('per_page');
        if ($per_page <= 0) {
            $per_page = 10;
        }
        if ($per_page > 100) {
            $per_page = 100;
        }
        
        $statuses = $this->getBooksStatuses();
        
        $query_args = ['post_type' => $post_type, 'post_status' => $statuses, 'fields' => 'ids', 'paged' => max(1, (int) $request->get_param('page')), 'posts_per_page' => $per_page];
        
        $meta_query = [];
        $statusMeta = $request->get_param('status');
        if ($statusMeta !== null) {
            $statusMeta = match (is_scalar($statusMeta)) {
                true => trim((string) $statusMeta),
                default => null,
            };
            if ($statusMeta !== null && $statusMeta !== '') {
                $meta_query[] = ['key' => 'status', 'compare' => '=', 'value' => $statusMeta];
            }
        }
        $tagsMeta = $request->get_param('tags');
        if ($tagsMeta !== null) {
            if (!is_array($tagsMeta)) {
                $tagsMeta = [$tagsMeta];
            }
            $tagsMeta = array_values((array) $tagsMeta);
            $tagsMeta = array_filter($tagsMeta, static fn($value) => match (trim((string) $value)) {
                '' => false,
                default => true,
            });
            if (count($tagsMeta) > 0) {
                $meta_query[] = ['key' => 'tags', 'compare' => 'IN', 'value' => $tagsMeta];
            }
        }
        if (count($meta_query) > 0) {
            $query_args['meta_query'] = $meta_query;
        }
        
        $tax_query = [];
        $genresTerms = $request->get_param('genres');
        if ($genresTerms !== null) {
            $genresTerms = array_filter(array_map(static fn($value) => (int) $value, (array) $genresTerms), static fn($value) => $value > 0);
            if (count($genresTerms) > 0) {
                $tax_query[] = ['taxonomy' => 'book_genre', 'field' => 'term_id', 'terms' => $genresTerms];
            }
        }
        if (count($tax_query) > 0) {
            $query_args['tax_query'] = $tax_query;
        }
        
        $query = new WP_Query($query_args);
        
        $items = [];
        
        foreach ($query->posts as $post_id) {
            $post = get_post($post_id);
            if (!$post instanceof WP_Post) {
                continue;
            }
            $items[] = $this->prepareBooksResponse($post, $request);
        }
        
        return ['items' => $items, 'total' => (int) $query->found_posts, 'pages' => (int) $query->max_num_pages];
    }
    /**
     * Handle [GET] /kernel/v1/books/:slug.
     * @wp-kernel route-kind get
     */
    public function getKernelV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        
        return $this->prepareBooksResponse($post, $request);
    }
    /**
     * Handle [POST] /kernel/v1/books.
     * @wp-kernel route-kind create
     * @wp-kernel resource.wpPost.mutation create
     */
    public function postKernelV1Books(WP_REST_Request $request)
    {
        $post_type = $this->getBooksPostType();
        $post_data = ['post_type' => $post_type];
        // @wp-kernel resource.wpPost.mutation status-validation
        // @wp-kernel mutation:status normalise
        $status = $request->get_param('status');
        $post_data['post_status'] = $this->normaliseBooksStatus($status);
        $post_id = wp_insert_post($post_data, true);
        if (is_wp_error($post_id)) {
            return $post_id;
        }
        if (0 === $post_id) {
            return new WP_Error('wpk_books_create_failed', 'Unable to create Books.', ['status' => 500]);
        }
        // @wp-kernel resource.wpPost.mutation sync-meta
        // @wp-kernel mutation:meta update
        $this->syncBooksMeta($post_id, $request);
        // @wp-kernel resource.wpPost.mutation sync-taxonomies
        // @wp-kernel mutation:taxonomies update
        $taxonomy_result = $this->syncBooksTaxonomies($post_id, $request);
        if (is_wp_error($taxonomy_result)) {
            return $taxonomy_result;
        }
        // @wp-kernel resource.wpPost.mutation cache-priming
        // @wp-kernel mutation:cache prime
        // @wp-kernel cache:wp-post prime
        $post = get_post($post_id);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_load_failed', 'Unable to load created Books.', ['status' => 500]);
        }
        return $this->prepareBooksResponse($post, $request);
    }
    /**
     * Handle [PUT] /kernel/v1/books/:slug.
     * @wp-kernel route-kind update
     * @wp-kernel resource.wpPost.mutation update
     */
    public function putKernelV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        $slug = $request->get_param('slug');
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        $post_data = ['ID' => $post->ID, 'post_type' => $this->getBooksPostType()];
        // @wp-kernel resource.wpPost.mutation status-validation
        // @wp-kernel mutation:status normalise
        $status = $request->get_param('status');
        if (null !== $status) {
            $post_data['post_status'] = $this->normaliseBooksStatus($status);
        }
        $result = wp_update_post($post_data, true);
        if (is_wp_error($result)) {
            return $result;
        }
        if (0 === $result) {
            return new WP_Error('wpk_books_update_failed', 'Unable to update Books.', ['status' => 500]);
        }
        // @wp-kernel resource.wpPost.mutation sync-meta
        // @wp-kernel mutation:meta update
        $this->syncBooksMeta($post->ID, $request);
        // @wp-kernel resource.wpPost.mutation sync-taxonomies
        // @wp-kernel mutation:taxonomies update
        $taxonomy_result = $this->syncBooksTaxonomies($post->ID, $request);
        if (is_wp_error($taxonomy_result)) {
            return $taxonomy_result;
        }
        // @wp-kernel resource.wpPost.mutation cache-priming
        // @wp-kernel mutation:cache prime
        // @wp-kernel cache:wp-post prime
        $updated = get_post($post->ID);
        if (!$updated instanceof WP_Post) {
            return new WP_Error('wpk_books_load_failed', 'Unable to load updated Books.', ['status' => 500]);
        }
        return $this->prepareBooksResponse($updated, $request);
    }
    /**
     * Handle [DELETE] /kernel/v1/books/:slug.
     * @wp-kernel route-kind remove
     * @wp-kernel resource.wpPost.mutation delete
     */
    public function deleteKernelV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        $slug = $request->get_param('slug');
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        $previous = $this->prepareBooksResponse($post, $request);
        $deleted = wp_delete_post($post->ID, true);
        if (false === $deleted) {
            return new WP_Error('wpk_books_delete_failed', 'Unable to delete Books.', ['status' => 500]);
        }
        return ['deleted' => true, 'id' => (int) $post->ID, 'previous' => $previous];
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: demo-option-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WP Kernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.demoOption
 * Schema: demoOption (manual)
 * Route: [GET] /kernel/v1/demo-option
 * Route: [PUT] /kernel/v1/demo-option
 */
namespace Demo\\Plugin\\Rest;

use WP_Error;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
final class DemoOptionController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'demoOption';
    }
    public function get_schema_key(): string
    {
        return 'demoOption';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Handle [GET] /kernel/v1/demo-option.
     * @wp-kernel route-kind custom
     */
    public function getKernelV1DemoOption(WP_REST_Request $request)
    {
        $option_name = $this->getDemoOptionOptionName();
        $value = get_option($option_name);
        
        return ['option' => $option_name, 'value' => $value];
    }
    /**
     * Handle [PUT] /kernel/v1/demo-option.
     * @wp-kernel route-kind custom
     */
    public function putKernelV1DemoOption(WP_REST_Request $request)
    {
        $option_name = $this->getDemoOptionOptionName();
        $previous = get_option($option_name);
        $value = $request->get_param('value');
        $autoload = $this->normaliseDemoOptionAutoload($request->get_param('autoload'));
        
        $updated = null !== $autoload ? update_option($option_name, $value, $autoload) : update_option($option_name, $value);
        
        $value_after = get_option($option_name);
        
        return ['option' => $option_name, 'updated' => (bool) $updated, 'value' => $value_after, 'previous' => $previous];
    }
    private function getDemoOptionOptionName(): string
    {
        return 'demo_option';
    }
    private function normaliseDemoOptionAutoload($value): ?string
    {
        if (null === $value) {
            return null;
        }
        if (is_bool($value)) {
            if ($value) {
                return 'yes';
            }
            return 'no';
        }
        if (is_numeric($value)) {
            if ((int) $value === 1) {
                return 'yes';
            }
            return 'no';
        }
        if (!is_string($value)) {
            return null;
        }
        $normalised = strtolower(trim((string) $value));
        if (in_array($normalised, ['1', 'true', 'yes'], true)) {
            return 'yes';
        }
        if (in_array($normalised, ['0', 'false', 'no'], true)) {
            return 'no';
        }
        return null;
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: job-cache-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WP Kernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.jobCache
 * Schema: jobCache (manual)
 * Route: [GET] /kernel/v1/job-cache
 * Route: [PUT] /kernel/v1/job-cache
 * Route: [DELETE] /kernel/v1/job-cache
 */
namespace Demo\\Plugin\\Rest;

use WP_Error;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
final class JobCacheController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'jobCache';
    }
    public function get_schema_key(): string
    {
        return 'jobCache';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Handle [GET] /kernel/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function getKernelV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $value = get_transient($key);
        
        return ['key' => $key, 'value' => $value];
    }
    /**
     * Handle [PUT] /kernel/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function putKernelV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $previous = get_transient($key);
        $value = $request->get_param('value');
        $expiration = $this->normaliseJobCacheExpiration($request->get_param('expiration'));
        
        $stored = set_transient($key, $value, $expiration);
        $current = get_transient($key);
        
        return ['key' => $key, 'stored' => (bool) $stored, 'value' => $current, 'previous' => $previous, 'expiration' => $expiration];
    }
    /**
     * Handle [DELETE] /kernel/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function deleteKernelV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $previous = get_transient($key);
        
        $deleted = delete_transient($key);
        
        return ['key' => $key, 'deleted' => (bool) $deleted, 'previous' => $previous];
    }
    private function getJobCacheTransientKey(...$segments): string
    {
        $parts = ['demo_plugin_job_cache'];
        foreach ($segments as $segment) {
            if (null !== $segment) {
                $normalised = trim((string) $segment);
                if (!('' === $normalised)) {
                    $parts[] = $normalised;
                }
            }
        }
        return implode('_', $parts);
    }
    private function normaliseJobCacheExpiration($value): int
    {
        if (null === $value) {
            return 0;
        }
        if (is_int($value)) {
            return max(0, $value);
        }
        if (is_numeric($value)) {
            return max(0, (int) $value);
        }
        if (!is_string($value)) {
            return 0;
        }
        $sanitised = trim((string) $value);
        if ('' === $sanitised) {
            return 0;
        }
        if (is_numeric($sanitised)) {
            return max(0, (int) $sanitised);
        }
        return 0;
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: policy-helper.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WP Kernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → policy-map ([fallback])
 */
namespace Demo\\Plugin\\Policy;

use WP_Error;
use WP_REST_Request;
// WPK:BEGIN AUTO
final class Policy
{
    public static function policy_map(): array
    {
        return [];
    }
    public static function fallback(): array
    {
        return ['appliesTo' => 'resource', 'capability' => 'manage_options'];
    }
    /** Create a permission callback closure for a policy. */
    public static function callback(string $policy_key): callable
    {
        return static function (WP_REST_Request $request) use ($policy_key) {
            return self::enforce($policy_key, $request);
        };
    }
    /**
     * Evaluate a policy against the current user.
     * @return bool|WP_Error
     */
    public static function enforce(string $policy_key, WP_REST_Request $request)
    {
        $definition = self::get_definition($policy_key);
        $fallback = self::fallback();
        $capability = isset($definition['capability']) ? $definition['capability'] : $fallback['capability'];
        $scope = isset($definition['appliesTo']) ? $definition['appliesTo'] : $fallback['appliesTo'];
        $allowed = current_user_can($capability);
        if ('object' === $scope) {
            $binding = self::get_binding($definition);
            if ($binding === null) {
                $binding = 'id';
            }
            $object_id = $request->get_param($binding);
            if ($object_id === null) {
                return self::create_error('wpk_policy_object_missing', sprintf('Object identifier parameter "%s" missing for policy "%s".', $binding, $policy_key));
            }
            $allowed = current_user_can($capability, $object_id);
        }
        if ($allowed) {
            return true;
        }
        return self::create_error('wpk_policy_denied', 'You are not allowed to perform this action.', ['policy' => $policy_key, 'capability' => $capability]);
    }
    private static function get_definition(string $policy_key): array
    {
        $map = self::policy_map();
        if (isset($map[$policy_key])) {
            return $map[$policy_key];
        }
        return self::fallback();
    }
    private static function get_binding(array $definition): ?string
    {
        $binding = isset($definition['binding']) ? $definition['binding'] : null;
        if (is_string($binding) && $binding !== '') {
            return $binding;
        }
        return null;
    }
    private static function create_error(string $code, string $message, array $context = []): WP_Error
    {
        $payload = array_merge(['status' => 403], $context);
        return new WP_Error($code, $message, $payload);
    }
}
// WPK:END AUTO
"
`;
