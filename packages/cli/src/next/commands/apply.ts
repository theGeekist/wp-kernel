import path from 'node:path';
import { Command, Option } from 'clipanion';
import { createReporter as buildReporter } from '@wpkernel/core/reporter';
import {
	KernelError,
	WPK_NAMESPACE,
	WPK_EXIT_CODES,
	type WPKExitCode,
} from '@wpkernel/core/contracts';
import type { BuilderOutput } from '../runtime/types';
import type { LoadedKernelConfig } from '../../config/types';
import { loadKernelConfig } from '../../config';
import { buildWorkspace, type Workspace } from '../workspace';
import { createPatcher } from '../builders';
import { determineExitCode, reportFailure } from '../../commands/apply/errors';

export const PATCH_MANIFEST_PATH = path.posix.join(
	'.wpk',
	'apply',
	'manifest.json'
);

export interface PatchManifestSummary {
	readonly applied: number;
	readonly conflicts: number;
	readonly skipped: number;
}

export type PatchStatus = 'applied' | 'conflict' | 'skipped';

export interface PatchRecord {
	readonly file: string;
	readonly status: PatchStatus;
	readonly description?: string;
	readonly details?: Record<string, unknown>;
}

export interface PatchManifest {
	readonly summary: PatchManifestSummary;
	readonly records: PatchRecord[];
}

export function buildBuilderOutput(): BuilderOutput {
	const actions: BuilderOutput['actions'] = [];
	return {
		actions,
		queueWrite(action) {
			actions.push(action);
		},
	};
}

export async function readManifest(
	workspace: Workspace
): Promise<PatchManifest | null> {
	const raw = await workspace.readText(PATCH_MANIFEST_PATH);
	if (!raw) {
		return null;
	}

	try {
		const data = JSON.parse(raw) as PatchManifest;
		if (!data.summary || !Array.isArray(data.records)) {
			throw new Error('Missing summary or records.');
		}

		return {
			summary: {
				applied: Number(data.summary.applied) || 0,
				conflicts: Number(data.summary.conflicts) || 0,
				skipped: Number(data.summary.skipped) || 0,
			},
			records: data.records.map((record) => ({
				file: String(record.file ?? ''),
				status: (record.status ?? 'skipped') as PatchStatus,
				description:
					typeof record.description === 'string'
						? record.description
						: undefined,
				details:
					typeof record.details === 'object' && record.details
						? record.details
						: undefined,
			})),
		} satisfies PatchManifest;
	} catch (error) {
		throw new KernelError('DeveloperError', {
			message: 'Failed to parse apply manifest.',
			context: {
				file: PATCH_MANIFEST_PATH,
				error: (error as Error).message,
			},
		});
	}
}

export function formatManifest(manifest: PatchManifest): string {
	const lines = [
		'Apply summary:',
		`  Applied: ${manifest.summary.applied}`,
		`  Conflicts: ${manifest.summary.conflicts}`,
		`  Skipped: ${manifest.summary.skipped}`,
	];

	if (manifest.records.length > 0) {
		lines.push('', 'Records:');
		for (const record of manifest.records) {
			const description = record.description
				? ` â€” ${record.description}`
				: '';
			lines.push(`- [${record.status}] ${record.file}${description}`);
		}
	} else {
		lines.push('', 'No files were patched.');
	}

	return `${lines.join('\n')}\n`;
}

export function resolveWorkspaceRoot(loaded: LoadedKernelConfig): string {
	return path.dirname(loaded.sourcePath);
}

function buildReporterNamespace(): string {
	return `${WPK_NAMESPACE}.cli.next.apply`;
}

export interface BuildApplyCommandOptions {
	readonly loadKernelConfig?: typeof loadKernelConfig;
	readonly buildWorkspace?: typeof buildWorkspace;
	readonly createPatcher?: typeof createPatcher;
	readonly buildReporter?: typeof buildReporter;
	readonly buildBuilderOutput?: typeof buildBuilderOutput;
	readonly readManifest?: typeof readManifest;
	readonly resolveWorkspaceRoot?: typeof resolveWorkspaceRoot;
}

type ApplyCommandDependencies = Required<BuildApplyCommandOptions>;

export type ApplyCommandConstructor = new () => Command & {
	summary: PatchManifestSummary | null;
	records: PatchRecord[];
	manifest: PatchManifest | null;
};

function mergeDependencies(
	options: BuildApplyCommandOptions
): ApplyCommandDependencies {
	return {
		loadKernelConfig,
		buildWorkspace,
		createPatcher,
		buildReporter,
		buildBuilderOutput,
		readManifest,
		resolveWorkspaceRoot,
		...options,
	} satisfies ApplyCommandDependencies;
}

export function buildApplyCommand(
	options: BuildApplyCommandOptions = {}
): ApplyCommandConstructor {
	const dependencies = mergeDependencies(options);

	class NextApplyCommand extends Command {
		static override paths = [['apply']];

		static override usage = Command.Usage({
			description:
				'Apply pending workspace patches generated by the next pipeline.',
			examples: [['Apply pending patches', 'wpk apply']],
		});

		yes = Option.Boolean('--yes', false);
		backup = Option.Boolean('--backup', false);
		force = Option.Boolean('--force', false);

		public summary: PatchManifestSummary | null = null;
		public records: PatchRecord[] = [];
		public manifest: PatchManifest | null = null;

		override async execute(): Promise<WPKExitCode> {
			const reporter = dependencies.buildReporter({
				namespace: buildReporterNamespace(),
				level: 'info',
				enabled: process.env.NODE_ENV !== 'test',
			});

			try {
				const loaded = await dependencies.loadKernelConfig();
				const workspaceRoot = dependencies.resolveWorkspaceRoot(loaded);
				const workspace = dependencies.buildWorkspace(workspaceRoot);
				const builder = dependencies.createPatcher();
				const output = dependencies.buildBuilderOutput();

				await builder.apply(
					{
						context: {
							workspace,
							reporter,
							phase: 'apply' as const,
						},
						input: {
							phase: 'apply' as const,
							options: {
								config: loaded.config,
								namespace: loaded.namespace,
								origin: loaded.configOrigin,
								sourcePath: loaded.sourcePath,
							},
							ir: null,
						},
						output,
						reporter,
					},
					undefined
				);

				const manifest = await dependencies.readManifest(workspace);
				if (!manifest) {
					const message =
						'No apply manifest produced - nothing to patch.';
					reporter.info(message);
					this.summary = { applied: 0, conflicts: 0, skipped: 0 };
					this.records = [];
					this.manifest = null;
					this.context.stdout.write(`${message}\n`);
					return WPK_EXIT_CODES.SUCCESS;
				}

				this.manifest = manifest;
				this.summary = manifest.summary;
				this.records = manifest.records;

				const outputText = formatManifest(manifest);
				this.context.stdout.write(outputText);

				if (manifest.summary.conflicts > 0) {
					reporter.warn('Apply completed with conflicts.', {
						summary: manifest.summary,
					});
					return WPK_EXIT_CODES.VALIDATION_ERROR;
				}

				reporter.info('Apply completed.', {
					summary: manifest.summary,
				});

				return WPK_EXIT_CODES.SUCCESS;
			} catch (error) {
				this.summary = null;
				this.records = [];
				this.manifest = null;
				reportFailure(
					reporter,
					'Failed to apply workspace patches.',
					error
				);
				return determineExitCode(error);
			}
		}
	}

	return NextApplyCommand as ApplyCommandConstructor;
}

export const NextApplyCommand = buildApplyCommand();
