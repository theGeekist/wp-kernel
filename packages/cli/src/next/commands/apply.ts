import path from 'node:path';
import { Command, Option } from 'clipanion';
import { createReporter } from '@wpkernel/core/reporter';
import { KernelError } from '@wpkernel/core/error';
import {
	WPK_NAMESPACE,
	WPK_EXIT_CODES,
	type WPKExitCode,
} from '@wpkernel/core/contracts';
import type { BuilderOutput } from '../runtime/types';
import type { IRv1 } from '../../ir/types';
import type { KernelConfigV1, LoadedKernelConfig } from '../../config/types';
import { loadKernelConfig } from '../../config';
import { createWorkspace, type Workspace } from '../workspace';
import { createPatcher } from '../builders';
import { determineExitCode, reportFailure } from '../../commands/apply/errors';

export const PATCH_MANIFEST_PATH = path.posix.join(
	'.wpk',
	'apply',
	'manifest.json'
);

interface PatchManifestSummary {
	readonly applied: number;
	readonly conflicts: number;
	readonly skipped: number;
}

export type PatchStatus = 'applied' | 'conflict' | 'skipped';

export interface PatchRecord {
	readonly file: string;
	readonly status: PatchStatus;
	readonly description?: string;
	readonly details?: Record<string, unknown>;
}

export interface PatchManifest {
	readonly summary: PatchManifestSummary;
	readonly records: PatchRecord[];
}

export function createBuilderOutput(): BuilderOutput {
	const actions: BuilderOutput['actions'] = [];
	return {
		actions,
		queueWrite(action) {
			actions.push(action);
		},
	};
}

export function createPolicyMap(): IRv1['policyMap'] {
	return {
		sourcePath: undefined,
		definitions: [],
		fallback: { capability: 'manage_options', appliesTo: 'resource' },
		missing: [],
		unused: [],
		warnings: [],
	};
}

export function createPhpProject(namespace: string): IRv1['php'] {
	return {
		namespace,
		autoload: 'inc/',
		outputDir: '.generated/php',
	};
}

export function createIrStub(
	config: KernelConfigV1,
	loaded: LoadedKernelConfig
): IRv1 {
	return {
		meta: {
			version: 1,
			namespace: loaded.namespace,
			sanitizedNamespace: loaded.namespace,
			origin: loaded.configOrigin,
			sourcePath: loaded.sourcePath,
		},
		config,
		schemas: [],
		resources: [],
		policies: [],
		policyMap: createPolicyMap(),
		blocks: [],
		php: createPhpProject(loaded.namespace),
	} satisfies IRv1;
}

export async function readManifest(
	workspace: Workspace
): Promise<PatchManifest | null> {
	const raw = await workspace.readText(PATCH_MANIFEST_PATH);
	if (!raw) {
		return null;
	}

	try {
		const data = JSON.parse(raw) as PatchManifest;
		if (!data.summary || !Array.isArray(data.records)) {
			throw new Error('Missing summary or records.');
		}

		return {
			summary: {
				applied: Number(data.summary.applied) || 0,
				conflicts: Number(data.summary.conflicts) || 0,
				skipped: Number(data.summary.skipped) || 0,
			},
			records: data.records.map((record) => ({
				file: String(record.file ?? ''),
				status: (record.status ?? 'skipped') as PatchStatus,
				description:
					typeof record.description === 'string'
						? record.description
						: undefined,
				details:
					typeof record.details === 'object' && record.details
						? record.details
						: undefined,
			})),
		} satisfies PatchManifest;
	} catch (error) {
		throw new KernelError('DeveloperError', {
			message: 'Failed to parse apply manifest.',
			context: {
				file: PATCH_MANIFEST_PATH,
				error: (error as Error).message,
			},
		});
	}
}

export function formatManifest(manifest: PatchManifest): string {
	const lines = [
		'Apply summary:',
		`  Applied: ${manifest.summary.applied}`,
		`  Conflicts: ${manifest.summary.conflicts}`,
		`  Skipped: ${manifest.summary.skipped}`,
	];

	if (manifest.records.length > 0) {
		lines.push('', 'Records:');
		for (const record of manifest.records) {
			const description = record.description
				? ` — ${record.description}`
				: '';
			lines.push(`- [${record.status}] ${record.file}${description}`);
		}
	} else {
		lines.push('', 'No files were patched.');
	}

	return `${lines.join('\n')}\n`;
}

export function resolveWorkspaceRoot(loaded: LoadedKernelConfig): string {
	return path.dirname(loaded.sourcePath);
}

function createReporterNamespace(): string {
	return `${WPK_NAMESPACE}.cli.next.apply`;
}

export class NextApplyCommand extends Command {
	static override paths = [['apply']];

	static override usage = Command.Usage({
		description:
			'Apply pending workspace patches generated by the next pipeline.',
		examples: [['Apply pending patches', 'wpk apply']],
	});

	yes = Option.Boolean('--yes', false);
	backup = Option.Boolean('--backup', false);
	force = Option.Boolean('--force', false);

	public summary: PatchManifestSummary | null = null;
	public records: PatchRecord[] = [];
	public manifest: PatchManifest | null = null;

	override async execute(): Promise<WPKExitCode> {
		const reporter = createReporter({
			namespace: createReporterNamespace(),
			level: 'info',
			enabled: process.env.NODE_ENV !== 'test',
		});

		try {
			const loaded = await loadKernelConfig();
			const workspaceRoot = resolveWorkspaceRoot(loaded);
			const workspace = createWorkspace(workspaceRoot);
			const builder = createPatcher();
			const output = createBuilderOutput();

			const ir = createIrStub(loaded.config, loaded);

			await builder.apply(
				{
					context: {
						workspace,
						reporter,
						phase: 'apply' as const,
					},
					input: {
						phase: 'apply' as const,
						options: {
							config: loaded.config,
							namespace: loaded.namespace,
							origin: loaded.configOrigin,
							sourcePath: loaded.sourcePath,
						},
						ir,
					},
					output,
					reporter,
				},
				undefined
			);

			const manifest = await readManifest(workspace);
			if (!manifest) {
				const message =
					'No apply manifest produced – nothing to patch.';
				reporter.info(message);
				this.summary = { applied: 0, conflicts: 0, skipped: 0 };
				this.records = [];
				this.manifest = null;
				this.context.stdout.write(`${message}\n`);
				return WPK_EXIT_CODES.SUCCESS;
			}

			this.manifest = manifest;
			this.summary = manifest.summary;
			this.records = manifest.records;

			const outputText = formatManifest(manifest);
			this.context.stdout.write(outputText);

			if (manifest.summary.conflicts > 0) {
				reporter.warn('Apply completed with conflicts.', {
					summary: manifest.summary,
				});
				return WPK_EXIT_CODES.VALIDATION_ERROR;
			}

			reporter.info('Apply completed.', {
				summary: manifest.summary,
			});

			return WPK_EXIT_CODES.SUCCESS;
		} catch (error) {
			this.summary = null;
			this.records = [];
			this.manifest = null;
			reportFailure(
				reporter,
				'Failed to apply workspace patches.',
				error
			);
			return determineExitCode(error);
		}
	}
}
