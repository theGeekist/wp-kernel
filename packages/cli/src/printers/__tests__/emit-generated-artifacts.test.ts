import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs/promises';
import { emitGeneratedArtifacts } from '..';
import { createNoopReporter } from '@geekist/wp-kernel';
import type { AdapterContext, KernelConfigV1 } from '../../config/types';
import type { IRResource, IRSchema, IRv1 } from '../../ir';
import type { PrinterContext } from '../types';
import { PhpFileBuilder } from '../php/builder';
import { renderPhpFile } from '../php/render';

const TMP_PREFIX = path.join(os.tmpdir(), 'wpk-printers-');

jest.mock('json-schema-to-typescript', () => ({
	compile: jest.fn(
		async (
			_schema,
			typeName: string,
			options?: { bannerComment?: string }
		) => {
			const banner = options?.bannerComment
				? `${options.bannerComment}\n\n`
				: '';
			return `${banner}export interface ${typeName} {\n  [key: string]: unknown;\n}\n`;
		}
	),
}));

describe('emitGeneratedArtifacts', () => {
	it('writes TypeScript types and index exports for IR schemas', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);

			await emitGeneratedArtifacts(context);

			const typeDir = path.join(context.outputDir, 'types');
			const manualPath = path.resolve(tempDir, 'types/job.d.ts');
			const autoPath = path.join(typeDir, 'task.d.ts');
			const literalPath = path.join(typeDir, 'literal.d.ts');
			const fallbackPath = path.join(typeDir, 'schema.d.ts');
			const indexPath = path.join(typeDir, 'index.d.ts');

			await expect(fs.stat(manualPath)).resolves.toMatchObject({});
			await expect(fs.stat(autoPath)).resolves.toMatchObject({});

			const manualContents = await fs.readFile(manualPath, 'utf8');
			expect(manualContents).toContain(
				'AUTO-GENERATED by WP Kernel CLI.'
			);
			expect(manualContents).toContain(
				'Source: kernel.config.ts → schemas.job'
			);
			expect(manualContents).toContain('export interface Job');

			const autoContents = await fs.readFile(autoPath, 'utf8');
			expect(autoContents).toContain(
				'Source: kernel.config.ts → schemas.auto:task'
			);
			expect(autoContents).toContain('export interface Task');

			const fallbackContents = await fs.readFile(fallbackPath, 'utf8');
			expect(fallbackContents).toContain(
				'Source: kernel.config.ts → schemas.auto:'
			);
			expect(fallbackContents).toContain('export interface Schema');

			await expect(fs.stat(literalPath)).resolves.toMatchObject({});
			await expect(fs.stat(fallbackPath)).resolves.toMatchObject({});

			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"export type { Job } from '../../types/job';"
			);
			expect(indexContents).toContain(
				"export type { Task } from './task';"
			);
			expect(indexContents).toContain(
				"export type { Literal } from './literal';"
			);
			expect(indexContents).toContain(
				"export type { Schema } from './schema';"
			);
		});
	});

	it('emits manual schema types when config directory is not provided', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);
			const absoluteTypesPath = path.join(tempDir, 'absolute/job.d.ts');
			context.ir.config.schemas.job.generated.types = absoluteTypesPath;
			context.configDirectory = undefined;

			await emitGeneratedArtifacts(context);

			const manualContents = await fs.readFile(absoluteTypesPath, 'utf8');
			expect(manualContents).toContain('export interface Job');

			const indexPath = path.join(
				context.outputDir,
				'types',
				'index.d.ts'
			);
			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"export type { Job } from '../../absolute/job';"
			);
		});
	});

	it('generates block manifests and auto-register for JS-only resources', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);

			await emitGeneratedArtifacts(context);

			const blocksRoot = path.join(context.outputDir, 'blocks');
			const literalManifestPath = path.join(
				blocksRoot,
				'literal',
				'block.json'
			);
			const remoteManifestPath = path.join(
				blocksRoot,
				'remote',
				'block.json'
			);
			const autoRegisterPath = path.join(blocksRoot, 'auto-register.ts');
			const literalEditorPath = path.join(
				blocksRoot,
				'literal',
				'index.tsx'
			);
			const literalViewPath = path.join(blocksRoot, 'literal', 'view.ts');

			const literalManifest = JSON.parse(
				await fs.readFile(literalManifestPath, 'utf8')
			);
			expect(literalManifest).toMatchObject({
				name: 'demo-namespace/literal',
				apiVersion: 3,
				editorScriptModule: 'file:./index.tsx',
				viewScriptModule: 'file:./view.ts',
			});

			const remoteManifest = JSON.parse(
				await fs.readFile(remoteManifestPath, 'utf8')
			);
			expect(remoteManifest.attributes).toMatchObject({
				id: expect.objectContaining({ type: 'integer' }),
				title: expect.objectContaining({ type: 'string' }),
			});

			const autoRegisterContents = await fs.readFile(
				autoRegisterPath,
				'utf8'
			);
			expect(autoRegisterContents).toContain(
				"registerBlockType('demo-namespace/literal'"
			);
			expect(autoRegisterContents).toContain(
				"registerBlockType('demo-namespace/remote'"
			);

			const editorContents = await fs.readFile(literalEditorPath, 'utf8');
			expect(editorContents).toContain('AUTO-GENERATED WPK STUB');
			expect(editorContents).toContain('registerBlockType');

			const viewContents = await fs.readFile(literalViewPath, 'utf8');
			expect(viewContents).toContain('initBlockView');
		});
	});

	it('produces SSR manifest and registrar when SSR blocks exist', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);
			const ssrBlockDir = path.join(
				tempDir,
				'src',
				'blocks',
				'ssr-block'
			);
			await fs.mkdir(ssrBlockDir, { recursive: true });

			const manifestPath = path.join(ssrBlockDir, 'block.json');
			await fs.writeFile(
				manifestPath,
				JSON.stringify({
					name: 'demo-namespace/ssr-block',
					title: 'SSR Block',
					icon: 'database',
					category: 'widgets',
					render: 'file:./render.php',
				}),
				'utf8'
			);
			await fs.writeFile(
				path.join(ssrBlockDir, 'render.php'),
				'<?php echo "SSR";'
			);

			context.ir.blocks = [
				...context.ir.blocks,
				{
					key: 'demo-namespace/ssr-block',
					directory: path.join('src', 'blocks', 'ssr-block'),
					hasRender: true,
					manifestSource: path.relative(tempDir, manifestPath),
				},
			];

			await emitGeneratedArtifacts(context);

			const manifestFile = path.join(
				context.outputDir,
				'build',
				'blocks-manifest.php'
			);
			const registrarFile = path.join(
				context.outputDir,
				'inc',
				'Blocks',
				'Register.php'
			);

			const manifestContents = await fs.readFile(manifestFile, 'utf8');
			expect(manifestContents).toContain("'demo-namespace/ssr-block'");
			expect(manifestContents).toContain(
				"'render' => 'src/blocks/ssr-block/render.php'"
			);

			const registrarContents = await fs.readFile(registrarFile, 'utf8');
			expect(registrarContents).toContain('final class Register');
			expect(registrarContents).toContain(
				'register_block_type_from_metadata'
			);
		});
	});

	it('emits PHP controllers, persistence registry, and index', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);

			await emitGeneratedArtifacts(context);

			const phpRoot = path.join(context.outputDir, 'php');
			const baseControllerPath = path.join(
				phpRoot,
				'Rest',
				'BaseController.php'
			);
			const jobControllerPath = path.join(
				phpRoot,
				'Rest',
				'JobController.php'
			);
			const taskControllerPath = path.join(
				phpRoot,
				'Rest',
				'TaskController.php'
			);
			const orphanControllerPath = path.join(
				phpRoot,
				'Rest',
				'OrphanController.php'
			);
			const persistencePath = path.join(
				phpRoot,
				'Registration',
				'PersistenceRegistry.php'
			);
			const indexPath = path.join(phpRoot, 'index.php');

			const baseContents = await fs.readFile(baseControllerPath, 'utf8');
			expect(baseContents).toContain('namespace Demo\\Namespace\\Rest;');
			expect(baseContents).toContain('AUTO-GENERATED by WP Kernel CLI.');
			expect(baseContents).toContain('// WPK:BEGIN AUTO');

			const jobContents = await fs.readFile(jobControllerPath, 'utf8');
			expect(jobContents).toContain('use WP_Error;');
			expect(jobContents).toContain('use WP_Post;');
			expect(jobContents).toContain('use WP_REST_Request;');
			expect(jobContents).toContain('use WP_Query;');
			expect(jobContents).toContain(
				'class JobController extends BaseController'
			);
			expect(jobContents).toContain("return 'job';");
			expect(jobContents).toContain('Route: [GET] /jobs');
			expect(jobContents).toContain(
				'public function getJobs( WP_REST_Request $request )'
			);
			expect(jobContents).toContain(
				'public function postJobs( WP_REST_Request $request )'
			);
			expect(jobContents).toContain('new WP_Query( $query_args )');
			expect(jobContents).toContain('wp_insert_post( $post_data, true )');
			expect(jobContents).toContain('return array(');
			expect(jobContents).toContain(
				'$this->prepareJobResponse( $post, $request );'
			);
			expect(jobContents).toContain(
				'$this->syncJobMeta( $post_id, $request );'
			);
			expect(jobContents).toContain(
				'$this->syncJobTaxonomies( $post_id, $request );'
			);
			expect(jobContents).not.toContain('Not Implemented');

			const jobRestArgs = extractPhpArrayPayload(jobContents);
			expect(jobRestArgs).toMatchObject({
				id: {
					identity: {
						param: 'id',
						type: 'number',
					},
					required: true,
					schema: {
						description: 'Identifier',
						minimum: 0,
						type: 'integer',
					},
				},
				log_path: {
					schema: {
						description: 'Windows log path for debugging',
						examples: [expect.stringMatching(/^C:/u)],
						type: 'string',
					},
				},
				search: {
					description: 'Search term',
					schema: {
						type: 'string',
					},
				},
				status: {
					schema: {
						enum: ['draft', 'published'],
						type: 'string',
					},
				},
				state: {
					schema: {
						enum: ['draft', 'published'],
						type: 'string',
					},
				},
				title: {
					schema: {
						description: 'Title',
						type: 'string',
					},
				},
			});

			const taskContents = await fs.readFile(taskControllerPath, 'utf8');
			expect(taskContents).toContain(
				'public function getTasksSlug( WP_REST_Request $request )'
			);
			expect(taskContents).toContain('$this->resolveTaskPost( $slug )');
			expect(taskContents).toContain(
				"return new WP_Error( 'wpk_task_not_found'"
			);
			expect(taskContents).toContain(
				'$this->prepareTaskResponse( $post, $request );'
			);
			const taskRestArgs = extractPhpArrayPayload(taskContents);
			expect(taskRestArgs).toEqual({
				slug: {
					identity: {
						param: 'slug',
						type: 'string',
					},
					required: true,
					schema: {
						type: 'string',
					},
				},
				status: {
					required: true,
					schema: {
						type: 'string',
					},
				},
				tags: {
					schema: {
						items: {
							enum: [],
							type: 'string',
						},
						type: 'array',
					},
				},
			});
			expect(taskContents).toContain(
				"$slug = $request->get_param( 'slug' );"
			);
			expect(taskContents).toContain('return array(');

			const orphanContents = await fs.readFile(
				orphanControllerPath,
				'utf8'
			);
			expect(orphanContents).toContain('return [];');
			expect(orphanContents).toContain(
				"return new WP_Error( 501, 'Not Implemented' );"
			);

			const literalControllerPath = path.join(
				phpRoot,
				'Rest',
				'LiteralController.php'
			);
			const literalContents = await fs.readFile(
				literalControllerPath,
				'utf8'
			);
			expect(literalContents).toContain(
				'class LiteralController extends BaseController'
			);
			expect(literalContents).toContain(
				'// TODO: Implement handler for [GET] /demo-namespace/literal.'
			);

			const literalRestArgs = extractPhpArrayPayload(literalContents);
			expect(literalRestArgs).toEqual([]);

			const remoteControllerPath = path.join(
				phpRoot,
				'Rest',
				'RemoteController.php'
			);
			await expect(fs.stat(remoteControllerPath)).rejects.toThrow();

			const persistenceContents = await fs.readFile(
				persistencePath,
				'utf8'
			);
			expect(persistenceContents).toContain('class PersistenceRegistry');
			expect(persistenceContents).toContain('storage');

			const persistencePayload =
				extractPhpArrayPayload(persistenceContents);
			expect(persistencePayload).toEqual({
				resources: {
					job: {
						identity: {
							param: 'id',
							type: 'number',
						},
						storage: {
							cacheTtl: 900,
							mode: 'wp-post',
							postType: 'job',
						},
					},
					literal: {
						identity: {
							param: 'uuid',
							type: 'string',
						},
						storage: null,
					},
					task: {
						identity: {
							param: 'slug',
							type: 'string',
						},
						storage: {
							meta: {
								status: {
									single: true,
									type: 'string',
								},
								tags: {
									items: {
										type: 'string',
									},
									single: false,
									type: 'array',
								},
							},
							mode: 'wp-post',
							postType: 'task',
							retryLimit: 2,
							revision: 3,
							supports: ['title', 'editor'],
						},
					},
				},
			});

			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Rest\\BaseController'"
			);
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Registration\\PersistenceRegistry'"
			);
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Rest\\LiteralController'"
			);
			expect(indexContents).not.toContain(
				"'Demo\\Namespace\\Rest\\RemoteController'"
			);
		});
	});

	it('emits UI scaffolding when DataViews metadata is present', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			ir.config.resources = {
				job: {
					name: 'job',
					routes: {
						list: { path: '/jobs', method: 'GET' },
					},
					ui: {
						admin: {
							view: 'dataviews',
							dataviews: {
								fields: [{ id: 'title', label: 'Title' }],
								defaultView: {
									type: 'table',
									fields: ['title'],
								},
								screen: {
									component: 'JobsAdminScreen',
									route: '/admin/jobs',
									resourceImport: '@/resources/job',
									kernelImport: '@/bootstrap/kernel',
									menu: {
										slug: 'jobs-admin',
										title: 'Jobs',
										capability: 'manage_options',
									},
								},
							},
						},
					},
				},
			} as unknown as typeof ir.config.resources;

			const context = createPrinterContext(tempDir, { ir });

			await emitGeneratedArtifacts(context);

			const uiRoot = path.join(context.outputDir, 'ui');
			const screenPath = path.join(
				uiRoot,
				'app',
				'job',
				'admin',
				'JobsAdminScreen.tsx'
			);
			const fixturePath = path.join(
				uiRoot,
				'fixtures',
				'dataviews',
				'job.ts'
			);
			const menuPath = path.join(
				context.outputDir,
				'php',
				'Admin',
				'Menu_JobsAdminScreen.php'
			);

			const screenContents = await fs.readFile(screenPath, 'utf8');
			expect(screenContents).toContain('JobsAdminScreenContent');
			expect(screenContents).toContain('resource={job}');
			expect(screenContents).toContain('jobsadminscreenRoute');

			const fixtureContents = await fs.readFile(fixturePath, 'utf8');
			expect(fixtureContents).toContain("label: 'Title'");
			expect(fixtureContents).toContain("type: 'table'");

			const menuContents = await fs.readFile(menuPath, 'utf8');
			expect(menuContents).toContain('namespace Demo\\Namespace\\Admin;');
			expect(menuContents).toContain('add_menu_page(');
			expect(menuContents).toContain("'jobs-admin'");
		});
	});

	it('warns when write routes are missing policies', async () => {
		await withTempDir(async (tempDir) => {
			const policyContext = createPrinterContext(tempDir);
			const job = policyContext.ir.resources.find(
				(resource) => resource.name === 'job'
			);

			if (!job) {
				throw new Error('Expected job resource in IR fixture');
			}

			for (const route of job.routes) {
				if (route.method !== 'POST') {
					continue;
				}
				delete route.policy;
			}

			const warnings: Array<{
				message: string;
				context?: unknown;
			}> = [];
			const baseReporter = createNoopReporter();
			const capturingReporter = {
				info: baseReporter.info,
				warn: (message: string, context?: unknown) => {
					warnings.push({ message, context });
					baseReporter.warn(message, context);
				},
				error: baseReporter.error,
				debug: baseReporter.debug,
				child: () => capturingReporter,
			} satisfies AdapterContext['reporter'];

			policyContext.adapterContext = {
				config: policyContext.ir.config,
				reporter: capturingReporter,
				namespace: policyContext.ir.meta.sanitizedNamespace,
				ir: policyContext.ir,
			};

			await emitGeneratedArtifacts(policyContext);

			expect(warnings).toContainEqual({
				message: 'Write route missing policy.',
				context: expect.objectContaining({
					resource: 'job',
					method: 'POST',
					path: '/jobs',
				}),
			});
		});
	});

	it('generates controllers when namespace sanitises to empty string', async () => {
		await withTempDir(async (tempDir) => {
			const emptyNamespaceContext = createPrinterContext(tempDir);
			emptyNamespaceContext.ir.meta.namespace = '';
			emptyNamespaceContext.ir.meta.sanitizedNamespace = '';

			await emitGeneratedArtifacts(emptyNamespaceContext);

			const jobControllerPath = path.join(
				emptyNamespaceContext.outputDir,
				'php',
				'Rest',
				'JobController.php'
			);
			const jobContents = await fs.readFile(jobControllerPath, 'utf8');
			expect(jobContents).toContain(
				'class JobController extends BaseController'
			);
		});
	});

	it('provides a noop reporter to adapter customisers by default', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);
			const reporters: AdapterContext['reporter'][] = [];

			context.phpAdapter = {
				customise(_builder, adapterContext) {
					reporters.push(adapterContext.reporter);
					expect(() =>
						adapterContext.reporter.info('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.warn('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.error('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.debug('demo')
					).not.toThrow();
				},
			};

			await emitGeneratedArtifacts(context);

			expect(reporters).not.toHaveLength(0);
			expect(context.adapterContext?.reporter).toBe(reporters[0]);
		});
	});

	it('repairs incomplete reporter implementations in adapter context overrides', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			const context = createPrinterContext(tempDir, { ir });
			const brokenReporter = {
				info: () => undefined,
			} as unknown as AdapterContext['reporter'];
			const reporters: AdapterContext['reporter'][] = [];

			context.adapterContext = {
				config: ir.config,
				reporter: brokenReporter,
				namespace: ir.meta.sanitizedNamespace,
				ir,
			} satisfies PrinterContext['adapterContext'];

			context.phpAdapter = {
				customise(_builder, adapterContext) {
					reporters.push(adapterContext.reporter);

					expect(() =>
						adapterContext.reporter.info('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.warn('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.error('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.debug('demo')
					).not.toThrow();
					expect(() =>
						adapterContext.reporter.child('test')
					).not.toThrow();
				},
			};

			await emitGeneratedArtifacts(context);

			expect(reporters).not.toHaveLength(0);
			const [firstReporter, ...rest] = reporters;
			for (const reporter of rest) {
				expect(reporter).toBe(firstReporter);
			}
			expect(firstReporter).not.toBe(brokenReporter);
			expect(context.adapterContext?.reporter).toBe(firstReporter);
		});
	});

	it('preserves valid adapter context reporters and metadata', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			const context = createPrinterContext(tempDir, { ir });
			const reporter = createNoopReporter().child('adapter');
			const adapterNamespace = 'Demo\\Override';

			const adapterContext = {
				config: ir.config,
				reporter,
				namespace: adapterNamespace,
				ir,
			} satisfies PrinterContext['adapterContext'];

			context.adapterContext = adapterContext;
			const reporters: AdapterContext['reporter'][] = [];

			context.phpAdapter = {
				customise(_builder, nextContext) {
					reporters.push(nextContext.reporter);
					expect(nextContext.reporter).toBe(reporter);
					expect(nextContext.namespace).toBe(adapterNamespace);
					expect(nextContext.config).toBe(ir.config);
				},
			};

			await emitGeneratedArtifacts(context);

			expect(reporters).not.toHaveLength(0);
			for (const nextReporter of reporters) {
				expect(nextReporter).toBe(reporter);
			}
			expect(context.adapterContext?.reporter).toBe(reporter);
			expect(context.adapterContext?.namespace).toBe(adapterNamespace);
		});
	});

	it('hydrates missing adapter context fields before customisers run', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			const context = createPrinterContext(tempDir, { ir });
			const reporters: AdapterContext['reporter'][] = [];

			context.adapterContext = {
				config: undefined,
				reporter: createNoopReporter(),
				namespace: undefined,
				ir: undefined,
			} as unknown as PrinterContext['adapterContext'];

			context.phpAdapter = {
				customise(_builder, nextContext) {
					reporters.push(nextContext.reporter);
					expect(nextContext.config).toBe(ir.config);
					expect(nextContext.namespace).toBe(
						ir.meta.sanitizedNamespace
					);
					expect(nextContext.ir).toBe(ir);
				},
			};

			await emitGeneratedArtifacts(context);

			expect(reporters).not.toHaveLength(0);
			expect(context.adapterContext?.config).toBe(ir.config);
			expect(context.adapterContext?.namespace).toBe(
				ir.meta.sanitizedNamespace
			);
			expect(context.adapterContext?.ir).toBe(ir);
		});
	});

	it('passes builders through adapter customisers', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			const context = createPrinterContext(tempDir, { ir });

			const customised: string[] = [];
			const adapterContext = {
				config: ir.config,
				reporter: createNoopReporter(),
				namespace: ir.meta.sanitizedNamespace,
				ir,
			} satisfies PrinterContext['adapterContext'];

			context.adapterContext = adapterContext;
			context.phpAdapter = {
				customise(builder) {
					const meta = builder.getMetadata();
					customised.push(meta.kind);
					if (meta.kind === 'resource-controller') {
						builder.appendDocblock('Customised by adapter');
						builder.addUse('WP_REST_Request');
						builder.addUse('   ');
						builder.getStatements();
					}
				},
			};

			await emitGeneratedArtifacts(context);

			const phpRoot = path.join(context.outputDir, 'php');
			const jobControllerPath = path.join(
				phpRoot,
				'Rest',
				'JobController.php'
			);
			const jobContents = await fs.readFile(jobControllerPath, 'utf8');
			expect(jobContents).toContain('Customised by adapter');
			expect(jobContents).toContain('use WP_REST_Request;');
			expect(customised).toEqual(
				expect.arrayContaining([
					'base-controller',
					'resource-controller',
					'persistence-registry',
				])
			);
		});
	});

	it('throws when encountering non-finite numbers during PHP rendering', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);
			const resource = context.ir.resources.find(
				(entry) => entry.name === 'job'
			);

			if (!resource) {
				throw new Error('Expected job resource to be present in IR');
			}

			resource.storage = {
				mode: 'wp-post',
				postType: 'job',
				meta: {
					unstable: {
						type: 'number',
						default: Number.POSITIVE_INFINITY,
					},
				},
			} as unknown as IRResource['storage'];

			await expect(emitGeneratedArtifacts(context)).rejects.toThrow(
				'Cannot render non-finite numbers in PHP output.'
			);
		});
	});
});

it('renders PHP files without docblocks or namespace declarations', () => {
	const builder = new PhpFileBuilder('', { kind: 'base-controller' });
	builder.appendStatement('class Example {}');

	const rendered = renderPhpFile(builder.toAst());

	expect(rendered).toContain('class Example {}');
	expect(rendered).not.toContain('namespace');
	expect(rendered).not.toContain('use ');
});

it('updates namespaces and deduplicates use statements in PhpFileBuilder', () => {
	const builder = new PhpFileBuilder('Demo\\Namespace', {
		kind: 'resource-controller',
		name: 'demo',
	});

	builder.setNamespace('Demo\\Override');
	builder.appendDocblock('Example docblock');
	builder.addUse(' WP_Error ');
	builder.addUse('WP_Error');
	builder.addUse('');
	builder.appendStatement('class DemoController {}');

	const ast = builder.toAst();

	expect(ast.namespace).toBe('Demo\\Override');
	expect(ast.docblock).toEqual(['Example docblock']);
	expect(ast.uses).toEqual(['WP_Error']);
	expect(ast.statements).toEqual(['class DemoController {}']);
});

async function withTempDir(run: (dir: string) => Promise<void>): Promise<void> {
	const tempDir = await fs.mkdtemp(TMP_PREFIX);
	try {
		await run(tempDir);
	} finally {
		await fs.rm(tempDir, { recursive: true, force: true });
	}
}

function createPrinterContext(
	tempDir: string,
	overrides: Partial<PrinterContext> & { ir?: IRv1 } = {}
): PrinterContext {
	const ir = overrides.ir ?? createIrFixture();
	const outputDir = path.join(tempDir, '.generated');

	const context: PrinterContext = {
		ir,
		outputDir,
		configDirectory: tempDir,
		formatPhp: async (_filePath, contents) =>
			ensureTrailingNewline(contents),
		formatTs: async (_filePath, contents) =>
			ensureTrailingNewline(contents),
		writeFile: async (filePath, contents) => {
			await fs.writeFile(
				filePath,
				ensureTrailingNewline(contents),
				'utf8'
			);
		},
		ensureDirectory: async (directoryPath) => {
			await fs.mkdir(directoryPath, { recursive: true });
		},
		...overrides,
	} as PrinterContext;

	return context;
}

function createIrFixture(): IRv1 {
	const config: KernelConfigV1 = {
		version: 1,
		namespace: 'demo-namespace',
		schemas: {
			job: {
				path: './contracts/job.schema.json',
				generated: {
					types: './.generated/../types/job.d.ts',
				},
			},
		},
		resources: {} as KernelConfigV1['resources'],
	} as KernelConfigV1;

	const jobSchema: IRSchema = {
		key: 'job',
		sourcePath: 'contracts/job.schema.json',
		hash: 'hash-job',
		schema: {
			type: 'object',
			required: ['id', 'status'],
			properties: {
				id: {
					type: 'integer',
					description: 'Identifier',
					minimum: 0,
				},
				log_path: {
					type: 'string',
					description: 'Windows log path for debugging',
					examples: ['C:\\logs\\'],
				},
				title: { type: 'string', description: 'Title' },
				status: {
					type: 'string',
					enum: ['draft', 'published'],
				},
			},
		},
		provenance: 'manual',
	};

	const taskSchema: IRSchema = {
		key: 'auto:task',
		sourcePath: '[storage:task]',
		hash: 'hash-task',
		schema: {
			type: 'object',
			required: ['slug', 'status'],
			properties: {
				slug: { type: 'string' },
				status: { type: 'string' },
				tags: {
					type: 'array',
					items: { type: 'string', enum: [] },
				},
			},
		},
		provenance: 'auto',
		generatedFrom: { type: 'storage', resource: 'task' },
	};

	const literalSchema: IRSchema = {
		key: 'literal',
		sourcePath: 'contracts/literal.schema.json',
		hash: 'hash-literal',
		schema: 'string' as unknown,
		provenance: 'manual',
	};

	const fallbackSchema: IRSchema = {
		key: 'auto:',
		sourcePath: '[storage:fallback]',
		hash: 'hash-fallback',
		schema: {
			type: 'object',
			properties: {},
		},
		provenance: 'auto',
		generatedFrom: { type: 'storage', resource: 'fallback' },
	};

	const jobResource: IRResource = {
		name: 'job',
		schemaKey: 'job',
		schemaProvenance: 'manual',
		routes: [
			{
				method: 'GET',
				path: '/jobs',
				hash: 'route-job-list',
				transport: 'local',
			},
			{
				method: 'POST',
				path: '/jobs',
				hash: 'route-job-create',
				policy: 'jobs.create',
				transport: 'local',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['job', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['job', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'number', param: 'id' } as IRResource['identity'],
		storage: {
			mode: 'wp-post',
			postType: 'job',
			cacheTtl: 900,
		} as IRResource['storage'],
		queryParams: {
			search: {
				type: 'string',
				description: 'Search term',
				optional: true,
			},
			state: {
				type: 'enum',
				enum: ['draft', 'published'],
			},
		},
		hash: 'resource-job',
	};

	const taskResource: IRResource = {
		name: 'task',
		schemaKey: 'auto:task',
		schemaProvenance: 'auto',
		routes: [
			{
				method: 'GET',
				path: '/tasks/:slug',
				hash: 'route-task-list',
				transport: 'local',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['task', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['task', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'string', param: 'slug' } as IRResource['identity'],
		storage: {
			mode: 'wp-post',
			postType: 'task',
			supports: ['title', 'editor'],
			retryLimit: 2,
			revision: BigInt(3),
			meta: {
				status: { type: 'string', single: true },
				tags: {
					type: 'array',
					single: false,
					items: { type: 'string' },
				},
			},
		} as unknown as IRResource['storage'],
		queryParams: undefined,
		hash: 'resource-task',
	};

	const literalResource: IRResource = {
		name: 'literal',
		schemaKey: 'literal',
		schemaProvenance: 'manual',
		routes: [
			{
				method: 'GET',
				path: '/demo-namespace/literal',
				hash: 'route-literal-get',
				transport: 'local',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['literal', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['literal', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'string', param: 'uuid' } as IRResource['identity'],
		queryParams: undefined,
		hash: 'resource-literal',
	};

	const orphanResource: IRResource = {
		name: 'orphan',
		schemaKey: 'missing',
		schemaProvenance: 'manual',
		routes: [
			{
				method: 'GET',
				path: '/orphans',
				hash: 'route-orphan-list',
				transport: 'local',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['orphan', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['orphan', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: undefined,
		storage: undefined,
		queryParams: undefined,
		hash: 'resource-orphan',
	};

	const remoteResource: IRResource = {
		name: 'remote',
		schemaKey: 'job',
		schemaProvenance: 'manual',
		routes: [
			{
				method: 'GET',
				path: 'https://api.example.com/jobs',
				hash: 'route-remote-list',
				transport: 'remote',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['remote', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['remote', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: undefined,
		storage: undefined,
		queryParams: undefined,
		hash: 'resource-remote',
	};

	const ir: IRv1 = {
		meta: {
			version: 1,
			namespace: 'demo-namespace',
			sourcePath: 'kernel.config.ts',
			origin: 'kernel.config.ts',
			sanitizedNamespace: 'Demo\\Namespace',
		},
		config,
		schemas: [jobSchema, taskSchema, literalSchema, fallbackSchema],
		resources: [
			jobResource,
			taskResource,
			literalResource,
			orphanResource,
			remoteResource,
		],
		policies: [],
		blocks: [],
		php: {
			namespace: 'Demo\\Namespace',
			autoload: 'inc/',
			outputDir: '.generated/php',
		},
	};

	return ir;
}

function extractPhpArrayPayload(contents: string): unknown {
	const returnIndex = contents.indexOf('return ');
	if (returnIndex === -1) {
		throw new Error('Unable to locate return statement in PHP file');
	}

	const expressionStart = contents.indexOf('[', returnIndex);
	if (expressionStart === -1) {
		if (/return\s*\[\s*\];/u.test(contents.slice(returnIndex))) {
			return [];
		}

		throw new Error('Unable to locate array payload in PHP file');
	}

	const { value } = parsePhpValue(contents, expressionStart);
	return value;
}

function parsePhpValue(
	input: string,
	index: number
): { value: unknown; nextIndex: number } {
	index = skipWhitespace(input, index);
	const char = input[index];

	if (char === '[') {
		return parsePhpArray(input, index);
	}

	if (char === "'") {
		return parsePhpString(input, index);
	}

	if (/[0-9-]/u.test(char ?? '')) {
		return parsePhpNumber(input, index);
	}

	if (input.startsWith('true', index)) {
		return { value: true, nextIndex: index + 4 };
	}

	if (input.startsWith('false', index)) {
		return { value: false, nextIndex: index + 5 };
	}

	if (input.startsWith('null', index)) {
		return { value: null, nextIndex: index + 4 };
	}

	throw new Error(
		`Unsupported PHP token near: ${input.slice(index, index + 20)}`
	);
}

function parsePhpArray(
	input: string,
	index: number
): { value: unknown; nextIndex: number } {
	let cursor = index + 1;
	const list: unknown[] = [];
	const entries: [string, unknown][] = [];
	let hasAssociativeKey = false;

	while (cursor < input.length) {
		cursor = skipWhitespace(input, cursor);

		if (input[cursor] === ']') {
			cursor += 1;
			break;
		}

		const entry = parsePhpArrayEntry(input, cursor);
		cursor = entry.nextIndex;

		if (entry.key === undefined) {
			list.push(entry.value);
		} else {
			hasAssociativeKey = true;
			entries.push([entry.key, entry.value]);
		}

		cursor = skipWhitespace(input, cursor);
		if (input[cursor] === ',') {
			cursor += 1;
		}
	}

	const value = hasAssociativeKey ? Object.fromEntries(entries) : list;

	return { value, nextIndex: cursor };
}

function parsePhpArrayEntry(
	input: string,
	index: number
): { key?: string; value: unknown; nextIndex: number } {
	if (input[index] === "'") {
		const keyResult = parsePhpString(input, index);
		const afterKey = skipWhitespace(input, keyResult.nextIndex);
		if (input.slice(afterKey, afterKey + 2) === '=>') {
			const valueResult = parsePhpValue(input, afterKey + 2);
			return {
				key: keyResult.value as string,
				value: valueResult.value,
				nextIndex: valueResult.nextIndex,
			};
		}
	}

	const valueResult = parsePhpValue(input, index);
	return { value: valueResult.value, nextIndex: valueResult.nextIndex };
}

function parsePhpString(
	input: string,
	index: number
): { value: string; nextIndex: number } {
	let cursor = index + 1;
	let result = '';

	while (cursor < input.length) {
		const char = input[cursor];

		if (char === '\\') {
			const next = input[cursor + 1];
			if (next === "'" || next === '\\') {
				result += next;
				cursor += 2;
				continue;
			}

			result += next ?? '';
			cursor += 2;
			continue;
		}

		if (char === "'") {
			cursor += 1;
			break;
		}

		result += char;
		cursor += 1;
	}

	return { value: result, nextIndex: cursor };
}

function parsePhpNumber(
	input: string,
	index: number
): { value: number; nextIndex: number } {
	const match = input.slice(index).match(/^-?\d+(?:\.\d+)?/u);

	if (!match) {
		throw new Error(
			`Unable to parse number near: ${input.slice(index, index + 20)}`
		);
	}

	return { value: Number(match[0]), nextIndex: index + match[0].length };
}

function skipWhitespace(input: string, index: number): number {
	while (index < input.length && /\s/u.test(input[index]!)) {
		index += 1;
	}

	return index;
}

function ensureTrailingNewline(value: string): string {
	return value.endsWith('\n') ? value : `${value}\n`;
}
