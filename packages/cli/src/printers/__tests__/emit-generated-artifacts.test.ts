import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs/promises';
import { emitGeneratedArtifacts } from '..';
import { createNoopReporter } from '@geekist/wp-kernel';
import type { KernelConfigV1 } from '../../config/types';
import type { IRResource, IRSchema, IRv1 } from '../../ir';
import type { PrinterContext } from '../types';
import { PhpFileBuilder } from '../php/builder';
import { renderPhpFile } from '../php/render';

const TMP_PREFIX = path.join(os.tmpdir(), 'wpk-printers-');

jest.mock('json-schema-to-typescript', () => ({
	compile: jest.fn(
		async (
			_schema,
			typeName: string,
			options?: { bannerComment?: string }
		) => {
			const banner = options?.bannerComment
				? `${options.bannerComment}\n\n`
				: '';
			return `${banner}export interface ${typeName} {\n  [key: string]: unknown;\n}\n`;
		}
	),
}));

describe('emitGeneratedArtifacts', () => {
	it('writes TypeScript types and index exports for IR schemas', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);

			await emitGeneratedArtifacts(context);

			const typeDir = path.join(context.outputDir, 'types');
			const manualPath = path.resolve(tempDir, 'types/job.d.ts');
			const autoPath = path.join(typeDir, 'task.d.ts');
			const literalPath = path.join(typeDir, 'literal.d.ts');
			const fallbackPath = path.join(typeDir, 'schema.d.ts');
			const indexPath = path.join(typeDir, 'index.d.ts');

			await expect(fs.stat(manualPath)).resolves.toMatchObject({});
			await expect(fs.stat(autoPath)).resolves.toMatchObject({});

			const manualContents = await fs.readFile(manualPath, 'utf8');
			expect(manualContents).toContain(
				'AUTO-GENERATED by WP Kernel CLI.'
			);
			expect(manualContents).toContain(
				'Source: kernel.config.ts → schemas.job'
			);
			expect(manualContents).toContain('export interface Job');

			const autoContents = await fs.readFile(autoPath, 'utf8');
			expect(autoContents).toContain(
				'Source: kernel.config.ts → schemas.auto:task'
			);
			expect(autoContents).toContain('export interface Task');

			const fallbackContents = await fs.readFile(fallbackPath, 'utf8');
			expect(fallbackContents).toContain(
				'Source: kernel.config.ts → schemas.auto:'
			);
			expect(fallbackContents).toContain('export interface Schema');

			await expect(fs.stat(literalPath)).resolves.toMatchObject({});
			await expect(fs.stat(fallbackPath)).resolves.toMatchObject({});

			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"export type { Job } from '../../types/job';"
			);
			expect(indexContents).toContain(
				"export type { Task } from './task';"
			);
			expect(indexContents).toContain(
				"export type { Literal } from './literal';"
			);
			expect(indexContents).toContain(
				"export type { Schema } from './schema';"
			);
		});
	});

	it('emits manual schema types when config directory is not provided', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);
			const absoluteTypesPath = path.join(tempDir, 'absolute/job.d.ts');
			context.ir.config.schemas.job.generated.types = absoluteTypesPath;
			context.configDirectory = undefined;

			await emitGeneratedArtifacts(context);

			const manualContents = await fs.readFile(absoluteTypesPath, 'utf8');
			expect(manualContents).toContain('export interface Job');

			const indexPath = path.join(
				context.outputDir,
				'types',
				'index.d.ts'
			);
			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"export type { Job } from '../../absolute/job';"
			);
		});
	});

	it('emits PHP controllers, persistence registry, and index', async () => {
		await withTempDir(async (tempDir) => {
			const context = createPrinterContext(tempDir);

			await emitGeneratedArtifacts(context);

			const phpRoot = path.join(context.outputDir, 'php');
			const baseControllerPath = path.join(
				phpRoot,
				'Rest',
				'BaseController.php'
			);
			const jobControllerPath = path.join(
				phpRoot,
				'Rest',
				'JobController.php'
			);
			const taskControllerPath = path.join(
				phpRoot,
				'Rest',
				'TaskController.php'
			);
			const orphanControllerPath = path.join(
				phpRoot,
				'Rest',
				'OrphanController.php'
			);
			const persistencePath = path.join(
				phpRoot,
				'Registration',
				'PersistenceRegistry.php'
			);
			const indexPath = path.join(phpRoot, 'index.php');

			const baseContents = await fs.readFile(baseControllerPath, 'utf8');
			expect(baseContents).toContain('namespace Demo\\Namespace\\Rest;');
			expect(baseContents).toContain('AUTO-GENERATED by WP Kernel CLI.');
			expect(baseContents).toContain('// WPK:BEGIN AUTO');

			const jobContents = await fs.readFile(jobControllerPath, 'utf8');
			expect(jobContents).toContain(
				'class JobController extends BaseController'
			);
			expect(jobContents).toContain("return 'job';");
			expect(jobContents).toContain('Route: [GET] /jobs');
			expect(jobContents).toContain('json_decode(');

			const jobRestArgs = extractPhpJsonPayload(jobContents);
			expect(jobRestArgs).toEqual({
				id: {
					identity: {
						param: 'id',
						type: 'number',
					},
					required: true,
					schema: {
						description: 'Identifier',
						type: 'integer',
					},
				},
				status: {
					required: true,
					schema: {
						enum: ['draft', 'published'],
						type: 'string',
					},
				},
				title: {
					schema: {
						description: 'Title',
						type: 'string',
					},
				},
			});

			const taskContents = await fs.readFile(taskControllerPath, 'utf8');
			const taskRestArgs = extractPhpJsonPayload(taskContents);
			expect(taskRestArgs).toEqual({
				slug: {
					identity: {
						param: 'slug',
						type: 'string',
					},
					required: true,
					schema: {
						type: 'string',
					},
				},
				status: {
					required: true,
					schema: {
						type: 'string',
					},
				},
				tags: {
					schema: {
						items: {
							type: 'string',
						},
						type: 'array',
					},
				},
			});

			const orphanContents = await fs.readFile(
				orphanControllerPath,
				'utf8'
			);
			expect(orphanContents).toContain('return [];');

			const literalControllerPath = path.join(
				phpRoot,
				'Rest',
				'LiteralController.php'
			);
			const literalContents = await fs.readFile(
				literalControllerPath,
				'utf8'
			);
			expect(literalContents).toContain(
				'class LiteralController extends BaseController'
			);

			const literalRestArgs = extractPhpJsonPayload(literalContents);
			expect(literalRestArgs).toEqual({});

			const persistenceContents = await fs.readFile(
				persistencePath,
				'utf8'
			);
			expect(persistenceContents).toContain('class PersistenceRegistry');
			expect(persistenceContents).toContain('storage');

			const persistencePayload =
				extractPhpJsonPayload(persistenceContents);
			expect(persistencePayload).toEqual({
				resources: {
					job: {
						identity: {
							param: 'id',
							type: 'number',
						},
						storage: {
							mode: 'wp-post',
							postType: 'job',
						},
					},
					literal: {
						identity: {
							param: 'uuid',
							type: 'string',
						},
						storage: {
							mode: 'wp-option',
							optionName: 'literal_mode',
						},
					},
					task: {
						identity: {
							param: 'slug',
							type: 'string',
						},
						storage: {
							meta: {
								status: {
									single: true,
									type: 'string',
								},
								tags: {
									items: {
										type: 'string',
									},
									single: false,
									type: 'array',
								},
							},
							mode: 'wp-post',
							postType: 'task',
							supports: ['title', 'editor'],
						},
					},
				},
			});

			const indexContents = await fs.readFile(indexPath, 'utf8');
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Rest\\BaseController'"
			);
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Registration\\PersistenceRegistry'"
			);
			expect(indexContents).toContain(
				"'Demo\\Namespace\\Rest\\LiteralController'"
			);
		});
	});

	it('passes builders through adapter customisers', async () => {
		await withTempDir(async (tempDir) => {
			const ir = createIrFixture();
			const context = createPrinterContext(tempDir, { ir });

			const customised: string[] = [];
			const adapterContext = {
				config: ir.config,
				reporter: createNoopReporter(),
				namespace: ir.meta.sanitizedNamespace,
				ir,
			} satisfies PrinterContext['adapterContext'];

			context.adapterContext = adapterContext;
			context.phpAdapter = {
				customise(builder) {
					const meta = builder.getMetadata();
					customised.push(meta.kind);
					if (meta.kind === 'resource-controller') {
						builder.appendDocblock('Customised by adapter');
						builder.addUse('WP_REST_Request');
						builder.addUse('   ');
						builder.getStatements();
					}
				},
			};

			await emitGeneratedArtifacts(context);

			const phpRoot = path.join(context.outputDir, 'php');
			const jobControllerPath = path.join(
				phpRoot,
				'Rest',
				'JobController.php'
			);
			const jobContents = await fs.readFile(jobControllerPath, 'utf8');
			expect(jobContents).toContain('Customised by adapter');
			expect(jobContents).toContain('use WP_REST_Request;');
			expect(customised).toEqual(
				expect.arrayContaining([
					'base-controller',
					'resource-controller',
					'persistence-registry',
				])
			);
		});
	});
});

it('renders PHP files without docblocks or namespace declarations', () => {
	const builder = new PhpFileBuilder('', { kind: 'base-controller' });
	builder.appendStatement('class Example {}');

	const rendered = renderPhpFile(builder.toAst());

	expect(rendered).toContain('class Example {}');
	expect(rendered).not.toContain('namespace');
	expect(rendered).not.toContain('use ');
});

it('updates namespaces and deduplicates use statements in PhpFileBuilder', () => {
	const builder = new PhpFileBuilder('Demo\\Namespace', {
		kind: 'resource-controller',
		name: 'demo',
	});

	builder.setNamespace('Demo\\Override');
	builder.appendDocblock('Example docblock');
	builder.addUse(' WP_Error ');
	builder.addUse('WP_Error');
	builder.addUse('');
	builder.appendStatement('class DemoController {}');

	const ast = builder.toAst();

	expect(ast.namespace).toBe('Demo\\Override');
	expect(ast.docblock).toEqual(['Example docblock']);
	expect(ast.uses).toEqual(['WP_Error']);
	expect(ast.statements).toEqual(['class DemoController {}']);
});

async function withTempDir(run: (dir: string) => Promise<void>): Promise<void> {
	const tempDir = await fs.mkdtemp(TMP_PREFIX);
	try {
		await run(tempDir);
	} finally {
		await fs.rm(tempDir, { recursive: true, force: true });
	}
}

function createPrinterContext(
	tempDir: string,
	overrides: Partial<PrinterContext> & { ir?: IRv1 } = {}
): PrinterContext {
	const ir = overrides.ir ?? createIrFixture();
	const outputDir = path.join(tempDir, '.generated');

	const context: PrinterContext = {
		ir,
		outputDir,
		configDirectory: tempDir,
		formatPhp: async (_filePath, contents) =>
			ensureTrailingNewline(contents),
		formatTs: async (_filePath, contents) =>
			ensureTrailingNewline(contents),
		...overrides,
	} as PrinterContext;

	return context;
}

function createIrFixture(): IRv1 {
	const config: KernelConfigV1 = {
		version: 1,
		namespace: 'demo-namespace',
		schemas: {
			job: {
				path: './contracts/job.schema.json',
				generated: {
					types: './.generated/../types/job.d.ts',
				},
			},
		},
		resources: {} as KernelConfigV1['resources'],
	} as KernelConfigV1;

	const jobSchema: IRSchema = {
		key: 'job',
		sourcePath: 'contracts/job.schema.json',
		hash: 'hash-job',
		schema: {
			type: 'object',
			required: ['id', 'status'],
			properties: {
				id: { type: 'integer', description: 'Identifier' },
				title: { type: 'string', description: 'Title' },
				status: {
					type: 'string',
					enum: ['draft', 'published'],
				},
			},
		},
		provenance: 'manual',
	};

	const taskSchema: IRSchema = {
		key: 'auto:task',
		sourcePath: '[storage:task]',
		hash: 'hash-task',
		schema: {
			type: 'object',
			required: ['slug', 'status'],
			properties: {
				slug: { type: 'string' },
				status: { type: 'string' },
				tags: {
					type: 'array',
					items: { type: 'string' },
				},
			},
		},
		provenance: 'auto',
		generatedFrom: { type: 'storage', resource: 'task' },
	};

	const literalSchema: IRSchema = {
		key: 'literal',
		sourcePath: 'contracts/literal.schema.json',
		hash: 'hash-literal',
		schema: {
			type: 'string',
			enum: ['alpha', 'beta'],
		},
		provenance: 'manual',
	};

	const fallbackSchema: IRSchema = {
		key: 'auto:',
		sourcePath: '[storage:fallback]',
		hash: 'hash-fallback',
		schema: {
			type: 'object',
			properties: {},
		},
		provenance: 'auto',
		generatedFrom: { type: 'storage', resource: 'fallback' },
	};

	const jobResource: IRResource = {
		name: 'job',
		schemaKey: 'job',
		schemaProvenance: 'manual',
		routes: [
			{ method: 'GET', path: '/jobs', hash: 'route-job-list' },
			{
				method: 'POST',
				path: '/jobs',
				hash: 'route-job-create',
				policy: 'jobs.create',
			},
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['job', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['job', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'number', param: 'id' } as IRResource['identity'],
		storage: { mode: 'wp-post', postType: 'job' } as IRResource['storage'],
		queryParams: undefined,
		hash: 'resource-job',
	};

	const taskResource: IRResource = {
		name: 'task',
		schemaKey: 'auto:task',
		schemaProvenance: 'auto',
		routes: [{ method: 'GET', path: '/tasks', hash: 'route-task-list' }],
		cacheKeys: {
			list: {
				segments: Object.freeze(['task', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['task', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'string', param: 'slug' } as IRResource['identity'],
		storage: {
			mode: 'wp-post',
			postType: 'task',
			supports: ['title', 'editor'],
			meta: {
				status: { type: 'string', single: true },
				tags: {
					type: 'array',
					single: false,
					items: { type: 'string' },
				},
			},
		} as IRResource['storage'],
		queryParams: undefined,
		hash: 'resource-task',
	};

	const literalResource: IRResource = {
		name: 'literal',
		schemaKey: 'literal',
		schemaProvenance: 'manual',
		routes: [
			{ method: 'GET', path: '/literal', hash: 'route-literal-get' },
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['literal', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['literal', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: { type: 'string', param: 'uuid' } as IRResource['identity'],
		storage: {
			mode: 'wp-option',
			optionName: 'literal_mode',
		} as IRResource['storage'],
		queryParams: undefined,
		hash: 'resource-literal',
	};

	const orphanResource: IRResource = {
		name: 'orphan',
		schemaKey: 'missing',
		schemaProvenance: 'manual',
		routes: [
			{ method: 'GET', path: '/orphans', hash: 'route-orphan-list' },
		],
		cacheKeys: {
			list: {
				segments: Object.freeze(['orphan', 'list']),
				source: 'config',
			},
			get: {
				segments: Object.freeze(['orphan', 'get', '__wpk_id__']),
				source: 'default',
			},
		},
		identity: undefined,
		storage: undefined,
		queryParams: undefined,
		hash: 'resource-orphan',
	};

	const ir: IRv1 = {
		meta: {
			version: 1,
			namespace: 'demo-namespace',
			sourcePath: 'kernel.config.ts',
			origin: 'kernel.config.ts',
			sanitizedNamespace: 'Demo\\Namespace',
		},
		config,
		schemas: [jobSchema, taskSchema, literalSchema, fallbackSchema],
		resources: [jobResource, taskResource, literalResource, orphanResource],
		policies: [],
		blocks: [],
		php: {
			namespace: 'Demo\\Namespace',
			autoload: 'inc/',
			outputDir: '.generated/php',
		},
	};

	return ir;
}

function extractPhpJsonPayload(contents: string): unknown {
	const match = contents.match(
		/return json_decode\([\s\S]*?'([^'\\]*(?:\\.[^'\\]*)*)',\s*true,/u
	);

	if (!match) {
		throw new Error('Unable to locate json_decode payload in PHP file');
	}

	const encoded = match[1]!;
	const unescapedBackslashes = encoded.replace(/\\\\/g, '\\');
	const json = unescapedBackslashes.replace(/\\'/g, "'");

	return JSON.parse(json);
}

function ensureTrailingNewline(value: string): string {
	return value.endsWith('\n') ? value : `${value}\n`;
}
