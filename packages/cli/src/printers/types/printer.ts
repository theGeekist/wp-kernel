import path from 'node:path';
import {
	compile,
	type JSONSchema,
	type Options as JsonSchemaToTsOptions,
} from 'json-schema-to-typescript';
import type { IRSchema } from '../../ir';
import type { PrinterContext } from '../types';

interface TypeArtifact {
	schema: IRSchema;
	filePath: string;
	typeName: string;
}

const DEFAULT_BANNER = [
	'AUTO-GENERATED by WP Kernel CLI.',
	'Changes within this file will be overwritten. Regenerate via the CLI.',
];

export async function emitTypeDefinitions(
	context: PrinterContext
): Promise<TypeArtifact[]> {
	const indexDirectory = path.resolve(context.outputDir, 'types');
	await context.ensureDirectory(indexDirectory);

	const artifacts: TypeArtifact[] = [];

	for (const schema of context.ir.schemas) {
		const artifact = await generateTypeForSchema(
			schema,
			context,
			indexDirectory
		);
		artifacts.push(artifact);
	}

	artifacts.sort((a, b) => a.typeName.localeCompare(b.typeName));

	const indexPath = path.join(indexDirectory, 'index.d.ts');
	const indexContents = createTypeIndex(indexPath, artifacts, context);
	const formattedIndex = await context.formatTs(indexPath, indexContents);
	await context.ensureDirectory(path.dirname(indexPath));
	await context.writeFile(indexPath, formattedIndex);

	return artifacts;
}

async function generateTypeForSchema(
	schema: IRSchema,
	context: PrinterContext,
	indexDirectory: string
): Promise<TypeArtifact> {
	const typeName = toPascalCase(schema.key);
	const targetPath = resolveTypeOutputPath(schema, context, indexDirectory);

	const compileOptions: Partial<JsonSchemaToTsOptions> = {
		bannerComment: createBanner(schema, context),
		style: {
			singleQuote: true,
		},
		unknownAny: false,
		unreachableDefinitions: false,
	};

	const compiled = await compile(
		schema.schema as JSONSchema,
		typeName,
		compileOptions
	);
	const formatted = await context.formatTs(targetPath, compiled);

	await context.ensureDirectory(path.dirname(targetPath));
	await context.writeFile(targetPath, formatted);

	return { schema, filePath: targetPath, typeName };
}

function createBanner(schema: IRSchema, context: PrinterContext): string {
	const lines = [
		'/**',
		...DEFAULT_BANNER.map((line) => ` * ${line}`),
		` * Source: ${context.ir.meta.origin} → schemas.${schema.key}`,
		` * Hash: ${schema.hash}`,
		' */',
	];

	return lines.join('\n');
}

function resolveTypeOutputPath(
	schema: IRSchema,
	context: PrinterContext,
	indexDirectory: string
): string {
	const schemaConfig =
		context.ir.config.schemas[
			schema.key as keyof typeof context.ir.config.schemas
		];

	if (schemaConfig?.generated?.types) {
		const configDirectory = resolveConfigDirectory(context);
		return path.resolve(configDirectory, schemaConfig.generated.types);
	}

	const inferredFileName =
		toKebabCase(schema.key.replace(/^auto:/, '')) || 'schema';
	return path.join(indexDirectory, `${inferredFileName}.d.ts`);
}

function resolveConfigDirectory(context: PrinterContext): string {
	if (context.configDirectory) {
		return context.configDirectory;
	}

	const inferredPath = path.resolve(
		process.cwd(),
		context.ir.meta.sourcePath
	);
	return path.dirname(inferredPath);
}

function createTypeIndex(
	indexPath: string,
	artifacts: TypeArtifact[],
	context: PrinterContext
): string {
	const indexDirectory = path.dirname(indexPath);
	const lines: string[] = [
		'/**',
		...DEFAULT_BANNER.map((line) => ` * ${line}`),
		` * Source: ${context.ir.meta.origin} → schemas`,
		' */',
		'',
	];

	for (const artifact of artifacts) {
		const relative = toRelativeModuleSpecifier(
			indexDirectory,
			artifact.filePath
		);
		lines.push(`export type { ${artifact.typeName} } from '${relative}';`);
	}

	lines.push('');
	return lines.join('\n');
}

function toRelativeModuleSpecifier(from: string, to: string): string {
	const relativePath = path.relative(from, to);
	const withoutExtension = relativePath.replace(/\.d\.ts$/u, '');
	const normalised = withoutExtension.split(path.sep).join('/');

	if (normalised.startsWith('.')) {
		return normalised;
	}

	return `./${normalised}`;
}

function toPascalCase(value: string): string {
	return (
		value
			.replace(/^auto:/, '')
			.split(/[^a-zA-Z0-9]+/u)
			.filter(Boolean)
			.map(
				(segment) => segment.charAt(0).toUpperCase() + segment.slice(1)
			)
			.join('') || 'Schema'
	);
}

function toKebabCase(value: string): string {
	return value
		.replace(/^auto:/, '')
		.split(/[^a-zA-Z0-9]+/u)
		.filter(Boolean)
		.map((segment) => segment.toLowerCase())
		.join('-');
}
