/**
 * JS-Only Block Printer (Phase 3A)
 *
 * Generates TypeScript registration code for blocks without server-side rendering.
 * Produces `src/blocks/auto-register.ts` with `registerBlockType()` calls.
 *
 * @module printers/blocks/js-only
 */

import path from 'node:path';
import fs from 'node:fs/promises';
import type { JSOnlyBlockOptions, BlockPrinterResult } from './types.js';
import {
	formatBlockVariableName,
	generateBlockImportPath,
	validateBlockManifest,
} from './shared/template-helpers.js';

/**
 * Generate registration code for JS-only blocks.
 *
 * Creates a TypeScript file that imports block.json files and registers them
 * with WordPress using `registerBlockType()`.
 *
 * @param options - Configuration for JS-only block generation
 * @return Generated files and warnings
 * @example
 * ```ts
 * const result = await generateJSOnlyBlocks({
 *   blocks: ir.blocks.filter(b => !b.ssr),
 *   outputDir: 'src/blocks',
 *   projectRoot: process.cwd()
 * });
 * ```
 * @internal
 */
export async function generateJSOnlyBlocks(
	options: JSOnlyBlockOptions
): Promise<BlockPrinterResult> {
	const blocks = options.blocks.filter((block) => !block.hasRender);

	if (blocks.length === 0) {
		return { files: [], warnings: [] };
	}

	const autoRegisterPath = path.join(options.outputDir, 'auto-register.ts');

	const blockResults = await Promise.all(
		blocks
			.sort((a, b) => a.key.localeCompare(b.key))
			.map((block) =>
				processBlockForAutoRegister({
					block,
					autoRegisterPath,
					projectRoot: options.projectRoot,
				})
			)
	);

	const warnings = blockResults.flatMap((result) => result.warnings);
	const stubFiles = blockResults.flatMap((result) => result.stubFiles);
	const imports = blockResults
		.map((result) => result.importStatement)
		.filter(isPresent);
	const registrations = blockResults
		.map((result) => result.registrationStatement)
		.filter(isPresent);
	const processedManifest = blockResults.some(
		(result) => result.processedManifest
	);
	const requiresSettingsHelper = blockResults.some(
		(result) => result.requiresSettingsHelper
	);

	if (
		!processedManifest &&
		stubFiles.length === 0 &&
		registrations.length === 0
	) {
		return { files: [], warnings };
	}

	const banner = [
		'/**',
		' * AUTO-GENERATED by WP Kernel CLI.',
		` * Source: ${options.source ?? 'project config'} â†’ blocks.jsOnly`,
		' */',
	];

	const files: BlockPrinterResult['files'] = [...stubFiles];

	const contents: string[] = [...banner];

	if (registrations.length > 0) {
		contents.push("import { registerBlockType } from '@wordpress/blocks';");
		if (requiresSettingsHelper) {
			contents.push(
				"import { createElement } from '@wordpress/element';"
			);
		}

		contents.push(...imports, '');

		if (requiresSettingsHelper) {
			contents.push(
				'function createGeneratedBlockSettings(metadata: { title?: string }) {',
				"        const title = metadata?.title ?? 'Block';",
				'        return {',
				'                edit: () =>',
				"                        createElement('div', null, `${title} (edit)`),",
				'                save: () =>',
				"                        createElement('div', null, `${title} (save)`),",
				'        };',
				'}',
				''
			);
		}

		contents.push(
			'export function registerGeneratedBlocks(): void {',
			...registrations.map((line) => `        ${line}`),
			'}',
			'',
			'registerGeneratedBlocks();',
			''
		);
	} else {
		contents.push(
			'export function registerGeneratedBlocks(): void {',
			'        // No JS-only blocks require auto-registration.',
			'}',
			'',
			'registerGeneratedBlocks();',
			''
		);
	}

	files.push({
		path: autoRegisterPath,
		content: contents.join('\n'),
	});

	return {
		files,
		warnings,
	};
}

interface BlockAutoRegisterResult {
	warnings: string[];
	stubFiles: BlockPrinterResult['files'];
	processedManifest: boolean;
	importStatement?: string;
	registrationStatement?: string;
	requiresSettingsHelper?: boolean;
}

async function processBlockForAutoRegister(options: {
	block: JSOnlyBlockOptions['blocks'][number];
	autoRegisterPath: string;
	projectRoot: string;
}): Promise<BlockAutoRegisterResult> {
	const { block, autoRegisterPath, projectRoot } = options;
	const manifestPath = path.resolve(projectRoot, block.manifestSource);
	const warnings: string[] = [];
	const stubFiles: BlockPrinterResult['files'] = [];

	let manifest: unknown;
	try {
		const raw = await fs.readFile(manifestPath, 'utf8');
		manifest = JSON.parse(raw);
	} catch (error) {
		warnings.push(
			`Unable to read manifest for block "${block.key}" at ${block.manifestSource}: ${String(
				error
			)}`
		);

		return {
			warnings,
			stubFiles,
			processedManifest: false,
		};
	}

	const manifestWarnings = validateBlockManifest(manifest, block);
	warnings.push(
		...manifestWarnings.map((message) => `Block "${block.key}": ${message}`)
	);

	if (!manifest || typeof manifest !== 'object') {
		return {
			warnings,
			stubFiles,
			processedManifest: false,
		};
	}

	const manifestData = manifest as Record<string, unknown>;
	const stubs = await generateBlockStubs({
		block,
		manifest: manifestData,
		projectRoot,
	});
	stubFiles.push(...stubs);

	if (blockRegistersViaFileModule(manifestData)) {
		return {
			warnings,
			stubFiles,
			processedManifest: true,
		};
	}

	const importPath = generateBlockImportPath(manifestPath, autoRegisterPath);
	const variableName = formatBlockVariableName(block.key);

	return {
		warnings,
		stubFiles,
		processedManifest: true,
		importStatement: `import ${variableName} from '${importPath}';`,
		registrationStatement: `registerBlockType(${variableName} as any, createGeneratedBlockSettings(${variableName}));`,
		requiresSettingsHelper: true,
	};
}

async function generateBlockStubs(options: {
	block: { directory: string };
	manifest: Record<string, unknown>;
	projectRoot: string;
}): Promise<BlockPrinterResult['files']> {
	const { block, manifest, projectRoot } = options;
	const blockDir = path.resolve(projectRoot, block.directory);
	const files: BlockPrinterResult['files'] = [];

	const editorModule =
		extractFileModulePath(manifest.editorScriptModule) ??
		extractFileModulePath(manifest.editorScript);
	if (editorModule && shouldEmitEditorStub(editorModule)) {
		const editorPath = path.resolve(blockDir, editorModule);
		if (!(await fileExists(editorPath))) {
			files.push({
				path: editorPath,
				content: createEditorStub(),
			});
		}
	}

	const viewModule =
		extractFileModulePath(manifest.viewScriptModule) ??
		extractFileModulePath(manifest.viewScript);
	if (viewModule && shouldEmitViewStub(viewModule)) {
		const viewPath = path.resolve(blockDir, viewModule);
		if (!(await fileExists(viewPath))) {
			files.push({
				path: viewPath,
				content: createViewStub(),
			});
		}
	}

	return files;
}

function extractFileModulePath(value: unknown): string | undefined {
	if (typeof value !== 'string' || !value.startsWith('file:')) {
		return undefined;
	}

	const relativePath = value.slice('file:'.length).trim();
	if (!relativePath) {
		return undefined;
	}

	if (relativePath.startsWith('./')) {
		return relativePath.slice(2);
	}

	return relativePath;
}

function shouldEmitEditorStub(relativePath: string): boolean {
	return normalizeRelative(relativePath) === 'index.tsx';
}

function shouldEmitViewStub(relativePath: string): boolean {
	return normalizeRelative(relativePath) === 'view.ts';
}

function normalizeRelative(candidate: string): string {
	const normalized = candidate.replace(/^\.\//u, '');
	return normalized.replace(/\\/gu, '/');
}

function blockRegistersViaFileModule(
	manifest: Record<string, unknown>
): boolean {
	return (
		usesFileModule(manifest.editorScriptModule) ||
		usesFileModule(manifest.editorScript)
	);
}

function usesFileModule(candidate: unknown): boolean {
	return (
		typeof candidate === 'string' &&
		candidate.trim().toLowerCase().startsWith('file:')
	);
}

function isPresent<T>(value: T | undefined | null): value is T {
	return value !== undefined && value !== null;
}

async function fileExists(filePath: string): Promise<boolean> {
	try {
		await fs.stat(filePath);
		return true;
	} catch {
		return false;
	}
}

function createEditorStub(): string {
	return [
		'/* AUTO-GENERATED WPK STUB: safe to edit. */',
		"import { registerBlockType } from '@wordpress/blocks';",
		'// Vite/tsconfig should allow JSON imports (.d.ts for JSON can be global)',
		"import metadata from './block.json';",
		'',
		'function Edit() {',
		"  return <div>{ metadata.title || 'Block' } (edit)</div>;",
		'}',
		'',
		'// Saved HTML is final for JS-only blocks:',
		'const save = () => (',
		"  <div>{ metadata.title || 'Block' } (save)</div>",
		');',
		'',
		'registerBlockType(metadata as any, { edit: Edit, save });',
		'',
	].join('\n');
}

function createViewStub(): string {
	return [
		'/* AUTO-GENERATED WPK STUB: safe to edit.',
		' * Runs on the front-end when the block appears.',
		' */',
		'export function initBlockView(root: HTMLElement) {',
		'  // Optional: hydrate interactivity',
		"  // console.log('Init view for', root);",
		'}',
		'',
	].join('\n');
}
