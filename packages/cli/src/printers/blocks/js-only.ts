/**
 * JS-Only Block Printer (Phase 3A)
 *
 * Generates TypeScript registration code for blocks without server-side rendering.
 * Produces `src/blocks/auto-register.ts` with `registerBlockType()` calls.
 *
 * @module printers/blocks/js-only
 */

import path from 'node:path';
import fs from 'node:fs/promises';
import type { JSOnlyBlockOptions, BlockPrinterResult } from './types.js';
import {
	formatBlockVariableName,
	generateBlockImportPath,
	validateBlockManifest,
} from './shared/template-helpers.js';

/**
 * Generate registration code for JS-only blocks.
 *
 * Creates a TypeScript file that imports block.json files and registers them
 * with WordPress using `registerBlockType()`.
 *
 * @param options - Configuration for JS-only block generation
 * @return Generated files and warnings
 * @example
 * ```ts
 * const result = await generateJSOnlyBlocks({
 *   blocks: ir.blocks.filter(b => !b.ssr),
 *   outputDir: 'src/blocks',
 *   projectRoot: process.cwd()
 * });
 * ```
 * @internal
 */
export async function generateJSOnlyBlocks(
	options: JSOnlyBlockOptions
): Promise<BlockPrinterResult> {
	const blocks = options.blocks.filter((block) => !block.hasRender);

	if (blocks.length === 0) {
		return { files: [], warnings: [] };
	}

	const autoRegisterPath = path.join(options.outputDir, 'auto-register.ts');

	const imports: string[] = [];
	const registrations: string[] = [];
	const warnings: string[] = [];
	const stubFiles: BlockPrinterResult['files'] = [];

	for (const block of blocks.sort((a, b) => a.key.localeCompare(b.key))) {
		const manifestPath = path.resolve(
			options.projectRoot,
			block.manifestSource
		);

		let manifest: unknown;
		try {
			const raw = await fs.readFile(manifestPath, 'utf8');
			manifest = JSON.parse(raw);
		} catch (error) {
			warnings.push(
				`Unable to read manifest for block "${block.key}" at ${block.manifestSource}: ${String(
					error
				)}`
			);
			continue;
		}

		const manifestWarnings = validateBlockManifest(manifest, block);
		warnings.push(
			...manifestWarnings.map(
				(message) => `Block "${block.key}": ${message}`
			)
		);

		if (manifest && typeof manifest === 'object') {
			const manifestData = manifest as Record<string, unknown>;
			const stubs = await generateBlockStubs({
				block,
				manifest: manifestData,
				projectRoot: options.projectRoot,
			});
			stubFiles.push(...stubs);
		}

		const importPath = generateBlockImportPath(
			manifestPath,
			autoRegisterPath
		);
		const variableName = formatBlockVariableName(block.key);

		imports.push(`import ${variableName} from '${importPath}';`);
		registrations.push(
			`registerBlockType('${block.key}', ${variableName});`
		);
	}

	if (imports.length === 0) {
		return { files: [], warnings };
	}

	const banner = [
		'/**',
		' * AUTO-GENERATED by WP Kernel CLI.',
		` * Source: ${options.source ?? 'project config'} â†’ blocks.jsOnly`,
		' */',
	];

	const contents = [
		...banner,
		"import { registerBlockType } from '@wordpress/blocks';",
		...imports,
		'',
		'export function registerGeneratedBlocks(): void {',
		...registrations.map((line) => `        ${line}`),
		'}',
		'',
		'registerGeneratedBlocks();',
		'',
	].join('\n');

	return {
		files: [
			...stubFiles,
			{
				path: autoRegisterPath,
				content: contents,
			},
		],
		warnings,
	};
}

async function generateBlockStubs(options: {
	block: { directory: string };
	manifest: Record<string, unknown>;
	projectRoot: string;
}): Promise<BlockPrinterResult['files']> {
	const { block, manifest, projectRoot } = options;
	const blockDir = path.resolve(projectRoot, block.directory);
	const files: BlockPrinterResult['files'] = [];

	const editorModule =
		extractFileModulePath(manifest.editorScriptModule) ??
		extractFileModulePath(manifest.editorScript);
	if (editorModule && shouldEmitEditorStub(editorModule)) {
		const editorPath = path.resolve(blockDir, editorModule);
		if (!(await fileExists(editorPath))) {
			files.push({
				path: editorPath,
				content: createEditorStub(),
			});
		}
	}

	const viewModule =
		extractFileModulePath(manifest.viewScriptModule) ??
		extractFileModulePath(manifest.viewScript);
	if (viewModule && shouldEmitViewStub(viewModule)) {
		const viewPath = path.resolve(blockDir, viewModule);
		if (!(await fileExists(viewPath))) {
			files.push({
				path: viewPath,
				content: createViewStub(),
			});
		}
	}

	return files;
}

function extractFileModulePath(value: unknown): string | undefined {
	if (typeof value !== 'string' || !value.startsWith('file:')) {
		return undefined;
	}

	const relativePath = value.slice('file:'.length).trim();
	if (!relativePath) {
		return undefined;
	}

	if (relativePath.startsWith('./')) {
		return relativePath.slice(2);
	}

	return relativePath;
}

function shouldEmitEditorStub(relativePath: string): boolean {
	return normalizeRelative(relativePath) === 'index.tsx';
}

function shouldEmitViewStub(relativePath: string): boolean {
	return normalizeRelative(relativePath) === 'view.ts';
}

function normalizeRelative(candidate: string): string {
	const normalized = candidate.replace(/^\.\//u, '');
	return normalized.replace(/\\/gu, '/');
}

async function fileExists(filePath: string): Promise<boolean> {
	try {
		await fs.stat(filePath);
		return true;
	} catch {
		return false;
	}
}

function createEditorStub(): string {
	return [
		'/* AUTO-GENERATED WPK STUB: safe to edit. */',
		"import { registerBlockType } from '@wordpress/blocks';",
		'// Vite/tsconfig should allow JSON imports (.d.ts for JSON can be global)',
		"import metadata from './block.json';",
		'',
		'function Edit() {',
		"  return <div>{ metadata.title || 'Block' } (edit)</div>;",
		'}',
		'',
		'// Saved HTML is final for JS-only blocks:',
		'const save = () => null;',
		'',
		'registerBlockType(metadata as any, { edit: Edit, save });',
		'',
	].join('\n');
}

function createViewStub(): string {
	return [
		'/* AUTO-GENERATED WPK STUB: safe to edit.',
		' * Runs on the front-end when the block appears.',
		' */',
		'export function initBlockView(root: HTMLElement) {',
		'  // Optional: hydrate interactivity',
		"  // console.log('Init view for', root);",
		'}',
		'',
	].join('\n');
}
