/**
 * JS-Only Block Printer (Phase 3A)
 *
 * Generates TypeScript registration code for blocks without server-side rendering.
 * Produces `src/blocks/auto-register.ts` with `registerBlockType()` calls.
 *
 * @module printers/blocks/js-only
 */

import path from 'node:path';
import fs from 'node:fs/promises';
import type { JSOnlyBlockOptions, BlockPrinterResult } from './types.js';
import {
	formatBlockVariableName,
	generateBlockImportPath,
	validateBlockManifest,
} from './shared/template-helpers.js';

/**
 * Generate registration code for JS-only blocks.
 *
 * Creates a TypeScript file that imports block.json files and registers them
 * with WordPress using `registerBlockType()`.
 *
 * @param options - Configuration for JS-only block generation
 * @return Generated files and warnings
 * @example
 * ```ts
 * const result = await generateJSOnlyBlocks({
 *   blocks: ir.blocks.filter(b => !b.ssr),
 *   outputDir: 'src/blocks',
 *   projectRoot: process.cwd()
 * });
 * ```
 * @internal
 */
export async function generateJSOnlyBlocks(
	options: JSOnlyBlockOptions
): Promise<BlockPrinterResult> {
	const blocks = options.blocks.filter((block) => !block.hasRender);

	if (blocks.length === 0) {
		return { files: [], warnings: [] };
	}

	const autoRegisterPath = path.join(options.outputDir, 'auto-register.ts');

	const imports: string[] = [];
	const registrations: string[] = [];
	const warnings: string[] = [];

	for (const block of blocks.sort((a, b) => a.key.localeCompare(b.key))) {
		const manifestPath = path.resolve(
			options.projectRoot,
			block.manifestSource
		);

		let manifest: unknown;
		try {
			const raw = await fs.readFile(manifestPath, 'utf8');
			manifest = JSON.parse(raw);
		} catch (error) {
			warnings.push(
				`Unable to read manifest for block "${block.key}" at ${block.manifestSource}: ${String(
					error
				)}`
			);
			continue;
		}

		const manifestWarnings = validateBlockManifest(manifest, block);
		warnings.push(
			...manifestWarnings.map(
				(message) => `Block "${block.key}": ${message}`
			)
		);

		const importPath = generateBlockImportPath(
			manifestPath,
			autoRegisterPath
		);
		const variableName = formatBlockVariableName(block.key);

		imports.push(`import ${variableName} from '${importPath}';`);
		registrations.push(
			`registerBlockType('${block.key}', ${variableName});`
		);
	}

	if (imports.length === 0) {
		return { files: [], warnings };
	}

	const banner = [
		'/**',
		' * AUTO-GENERATED by WP Kernel CLI.',
		` * Source: ${options.source ?? 'project config'} â†’ blocks.jsOnly`,
		' */',
	];

	const contents = [
		...banner,
		"import { registerBlockType } from '@wordpress/blocks';",
		...imports,
		'',
		'export function registerGeneratedBlocks(): void {',
		...registrations.map((line) => `        ${line}`),
		'}',
		'',
		'registerGeneratedBlocks();',
		'',
	].join('\n');

	return {
		files: [
			{
				path: autoRegisterPath,
				content: contents,
			},
		],
		warnings,
	};
}
