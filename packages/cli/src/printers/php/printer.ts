import path from 'node:path';
import { createNoopReporter } from '@geekist/wp-kernel';
import type { Reporter } from '@geekist/wp-kernel';
import type { AdapterContext } from '../../config/types';
import type { IRResource, IRSchema } from '../../ir';
import type { PrinterContext } from '../types';
import { PhpFileBuilder } from './builder';
import { renderPhpFile } from './render';
import type { PhpFileMetadata } from './types';

const DEFAULT_DOC_HEADER = [
	'AUTO-GENERATED by WP Kernel CLI.',
	'Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.',
];

const INDENT = '        ';

export async function emitPhpArtifacts(context: PrinterContext): Promise<void> {
	const phpRoot = path.resolve(context.outputDir, 'php');
	await context.ensureDirectory(phpRoot);

	const namespaceRoot = context.ir.php.namespace;

	const baseControllerPath = path.join(phpRoot, 'Rest', 'BaseController.php');
	const baseControllerBuilder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, {
		kind: 'base-controller',
	});
	initialiseBaseController(baseControllerBuilder, context);
	await writePhpArtifact(baseControllerPath, baseControllerBuilder, context);

	const resourceEntries: { className: string; path: string }[] = [];

	for (const resource of context.ir.resources) {
		const className = toPascalCase(resource.name);
		const metadata: PhpFileMetadata = {
			kind: 'resource-controller',
			name: resource.name,
		};

		const builder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, metadata);
		initialiseResourceController(builder, resource, context);

		const filePath = path.join(
			phpRoot,
			'Rest',
			`${className}Controller.php`
		);
		await writePhpArtifact(filePath, builder, context);

		resourceEntries.push({
			className: `${namespaceRoot}\\Rest\\${className}Controller`,
			path: filePath,
		});
	}

	const persistenceBuilder = new PhpFileBuilder(
		`${namespaceRoot}\\Registration`,
		{
			kind: 'persistence-registry',
		}
	);
	initialisePersistenceRegistry(persistenceBuilder, context);
	const persistencePath = path.join(
		phpRoot,
		'Registration',
		'PersistenceRegistry.php'
	);
	await writePhpArtifact(persistencePath, persistenceBuilder, context);

	const indexPath = path.join(phpRoot, 'index.php');
	const indexContents = createPhpIndex(
		indexPath,
		namespaceRoot,
		baseControllerPath,
		resourceEntries,
		persistencePath,
		context
	);
	const formattedIndex = await context.formatPhp(indexPath, indexContents);
	await context.ensureDirectory(path.dirname(indexPath));
	await context.writeFile(indexPath, formattedIndex);
}

function initialiseBaseController(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (namespace: ${context.ir.meta.sanitizedNamespace})`
	);

	const statements = [
		'abstract class BaseController',
		'{',
		`${INDENT}public function get_namespace(): string`,
		`${INDENT}{`,
		`${INDENT}${INDENT}return '${escapeSingleQuotes(context.ir.meta.sanitizedNamespace)}';`,
		`${INDENT}}`,
		'}',
	];

	for (const statement of statements) {
		builder.appendStatement(statement);
	}
}

function initialiseResourceController(
	builder: PhpFileBuilder,
	resource: IRResource,
	context: PrinterContext
): void {
	const schema = context.ir.schemas.find(
		(entry) => entry.key === resource.schemaKey
	);

	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources.${resource.name}`
	);
	builder.appendDocblock(
		`Schema: ${resource.schemaKey} (${resource.schemaProvenance})`
	);

	for (const route of resource.routes) {
		builder.appendDocblock(`Route: [${route.method}] ${route.path}`);
	}

	const className = `${toPascalCase(resource.name)}Controller`;
	builder.appendStatement(`class ${className} extends BaseController`);
	builder.appendStatement('{');

	builder.appendStatement(
		`${INDENT}public function get_resource_name(): string`
	);
	builder.appendStatement(`${INDENT}{`);
	builder.appendStatement(
		`${INDENT}${INDENT}return '${escapeSingleQuotes(resource.name)}';`
	);
	builder.appendStatement(`${INDENT}}`);

	builder.appendStatement('');
	builder.appendStatement(
		`${INDENT}public function get_schema_key(): string`
	);
	builder.appendStatement(`${INDENT}{`);
	builder.appendStatement(
		`${INDENT}${INDENT}return '${escapeSingleQuotes(resource.schemaKey)}';`
	);
	builder.appendStatement(`${INDENT}}`);

	builder.appendStatement('');
	builder.appendStatement(`${INDENT}public function get_rest_args(): array`);
	builder.appendStatement(`${INDENT}{`);

	if (schema) {
		const restArgs = buildRestArgsPayload(schema, resource);
		const payloadLines = renderPhpReturn(restArgs, 2);
		for (const line of payloadLines) {
			builder.appendStatement(line);
		}
	} else {
		builder.appendStatement(`${INDENT}${INDENT}return [];`);
	}

	builder.appendStatement(`${INDENT}}`);
	builder.appendStatement('}');
}

function initialisePersistenceRegistry(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (storage + identity metadata)`
	);

	builder.appendStatement('final class PersistenceRegistry');
	builder.appendStatement('{');
	builder.appendStatement(
		`${INDENT}public static function get_config(): array`
	);
	builder.appendStatement(`${INDENT}{`);

	const payload = buildPersistencePayload(context);
	const payloadLines = renderPhpReturn(payload, 2);
	for (const line of payloadLines) {
		builder.appendStatement(line);
	}

	builder.appendStatement(`${INDENT}}`);
	builder.appendStatement('}');
}

async function writePhpArtifact(
	filePath: string,
	builder: PhpFileBuilder,
	context: PrinterContext
): Promise<void> {
	const adapterContext = ensureAdapterContext(context);

	if (context.phpAdapter?.customise) {
		context.phpAdapter.customise(builder, adapterContext);
	}

	const ast = builder.toAst();
	const rendered = renderPhpFile(ast);
	const formatted = await context.formatPhp(filePath, rendered);
	await context.ensureDirectory(path.dirname(filePath));
	await context.writeFile(filePath, formatted);
}

function ensureAdapterContext(
	context: PrinterContext
): AdapterContext & { ir: PrinterContext['ir'] } {
	if (context.adapterContext) {
		const adapterContext: AdapterContext & {
			ir: PrinterContext['ir'];
		} = {
			...context.adapterContext,
			config: context.adapterContext.config ?? context.ir.config,
			reporter: isReporter(context.adapterContext.reporter)
				? context.adapterContext.reporter
				: createNoopReporter(),
			namespace:
				context.adapterContext.namespace ??
				context.ir.meta.sanitizedNamespace,
			ir: context.adapterContext.ir ?? context.ir,
		};

		context.adapterContext = adapterContext;

		return adapterContext;
	}

	const adapterContext: AdapterContext & {
		ir: PrinterContext['ir'];
	} = {
		config: context.ir.config,
		reporter: createNoopReporter(),
		namespace: context.ir.meta.sanitizedNamespace,
		ir: context.ir,
	};

	context.adapterContext = adapterContext;

	return adapterContext;
}

function isReporter(value: unknown): value is Reporter {
	if (!value || typeof value !== 'object') {
		return false;
	}

	const candidate = value as Record<string, unknown>;
	return (
		typeof candidate.info === 'function' &&
		typeof candidate.warn === 'function' &&
		typeof candidate.error === 'function' &&
		typeof candidate.debug === 'function' &&
		typeof candidate.child === 'function'
	);
}

function createPhpIndex(
	indexPath: string,
	namespaceRoot: string,
	baseControllerPath: string,
	resourceEntries: { className: string; path: string }[],
	persistencePath: string,
	context: PrinterContext
): string {
	const indexDir = path.dirname(indexPath);

	const entries = [
		{
			className: `${namespaceRoot}\\Rest\\BaseController`,
			path: baseControllerPath,
		},
		...resourceEntries,
		{
			className: `${namespaceRoot}\\Registration\\PersistenceRegistry`,
			path: persistencePath,
		},
	];

	const lines: string[] = ['<?php', 'declare(strict_types=1);', ''];
	lines.push('/**');
	for (const line of DEFAULT_DOC_HEADER) {
		lines.push(` * ${line}`);
	}
	lines.push(` * Source: ${context.ir.meta.origin} → php/index`);
	lines.push(' */', '', 'return [');

	for (const entry of entries) {
		const relative = path
			.relative(indexDir, entry.path)
			.split(path.sep)
			.join('/');
		const suffix = relative.startsWith('/') ? relative : `/${relative}`;
		lines.push(`${INDENT}'${entry.className}' => __DIR__ . '${suffix}',`);
	}

	lines.push('];', '');
	return lines.join('\n');
}

function buildRestArgsPayload(schema: IRSchema, resource: IRResource): unknown {
	const schemaValue = schema.schema;
	if (!isRecord(schemaValue)) {
		return {};
	}

	const required = new Set(
		Array.isArray(schemaValue.required)
			? (schemaValue.required as string[])
			: []
	);

	const properties = isRecord(schemaValue.properties)
		? (schemaValue.properties as Record<string, unknown>)
		: {};

	const restArgs: Record<string, unknown> = {};
	for (const [key, descriptor] of Object.entries(properties)) {
		const payload: Record<string, unknown> = {};
		payload.schema = sanitizeJson(descriptor);
		if (required.has(key)) {
			payload.required = true;
		}

		if (resource.identity?.param === key) {
			payload.identity = resource.identity;
		}

		restArgs[key] = payload;
	}

	return restArgs;
}

function buildPersistencePayload(context: PrinterContext): unknown {
	const resources: Record<string, unknown> = {};

	for (const resource of context.ir.resources) {
		if (!resource.storage && !resource.identity) {
			continue;
		}

		resources[resource.name] = sanitizeJson({
			storage: resource.storage ?? null,
			identity: resource.identity ?? null,
		});
	}

	return { resources };
}

function renderPhpReturn(value: unknown, indentLevel: number): string[] {
	const expressionLines = renderPhpExpression(value, indentLevel);

	const indent = INDENT.repeat(indentLevel);
	const firstLine = expressionLines[0]!;
	const remainder = firstLine.slice(indent.length);
	expressionLines[0] = `${indent}return ${remainder}`;

	const lastIndex = expressionLines.length - 1;
	expressionLines[lastIndex] = `${expressionLines[lastIndex]};`;

	return expressionLines;
}

function renderPhpExpression(value: unknown, indentLevel: number): string[] {
	const indent = INDENT.repeat(indentLevel);

	if (Array.isArray(value)) {
		return renderPhpList(value, indentLevel, indent);
	}

	if (isRecord(value)) {
		return renderPhpAssociative(
			value as Record<string, unknown>,
			indentLevel,
			indent
		);
	}

	return renderPhpScalar(value, indent);
}

function renderPhpList(
	value: unknown[],
	indentLevel: number,
	indent: string
): string[] {
	if (value.length === 0) {
		return [`${indent}[]`];
	}

	const lines = [`${indent}[`];
	for (const entry of value) {
		const rendered = renderPhpExpression(entry, indentLevel + 1);
		const last = rendered.length - 1;
		rendered[last] = `${rendered[last]},`;
		lines.push(...rendered);
	}

	lines.push(`${indent}]`);
	return lines;
}

function renderPhpAssociative(
	value: Record<string, unknown>,
	indentLevel: number,
	indent: string
): string[] {
	const entries = Object.entries(value);
	if (entries.length === 0) {
		return [`${indent}[]`];
	}

	const lines = [`${indent}[`];
	const childIndent = INDENT.repeat(indentLevel + 1);

	for (const [key, val] of entries) {
		const rendered = renderPhpExpression(val, indentLevel + 1);
		if (rendered.length === 0) {
			continue;
		}
		const firstLine = rendered[0]!;
		const remainder = firstLine.slice(childIndent.length);
		rendered[0] = `${childIndent}'${escapeSingleQuotes(key)}' => ${remainder}`;
		const last = rendered.length - 1;
		rendered[last] = `${rendered[last]},`;
		lines.push(...rendered);
	}

	lines.push(`${indent}]`);
	return lines;
}

function renderPhpScalar(value: unknown, indent: string): string[] {
	if (typeof value === 'string') {
		return [`${indent}'${escapeSingleQuotes(value)}'`];
	}

	if (typeof value === 'number') {
		if (!Number.isFinite(value)) {
			throw new Error('Cannot render non-finite numbers in PHP output.');
		}

		return [`${indent}${value}`];
	}

	if (typeof value === 'bigint') {
		return [`${indent}${value.toString()}`];
	}

	if (typeof value === 'boolean') {
		return [`${indent}${value ? 'true' : 'false'}`];
	}

	if (value === null) {
		return [`${indent}null`];
	}

	throw new Error(`Unsupported PHP value: ${String(value)}`);
}

function sanitizeJson(value: unknown): unknown {
	if (Array.isArray(value)) {
		return value.map((entry) => sanitizeJson(entry));
	}

	if (isRecord(value)) {
		const entries = Object.entries(value)
			.map(([key, val]) => [key, sanitizeJson(val)] as const)
			.sort(([a], [b]) => a.localeCompare(b));
		return Object.fromEntries(entries);
	}

	return value;
}

function isRecord(value: unknown): value is Record<string, unknown> {
	return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}

function toPascalCase(value: string): string {
	return (
		value
			.split(/[^a-zA-Z0-9]+/u)
			.filter(Boolean)
			.map(
				(segment) => segment.charAt(0).toUpperCase() + segment.slice(1)
			)
			.join('') || 'Resource'
	);
}

function escapeSingleQuotes(value: string): string {
	return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}
