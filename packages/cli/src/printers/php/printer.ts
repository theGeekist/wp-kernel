import path from 'node:path';
import { promises as fs } from 'node:fs';
import { createNoopReporter } from '@geekist/wp-kernel';
import type { AdapterContext } from '../../config/types';
import type { IRResource, IRSchema } from '../../ir';
import type { PrinterContext } from '../types';
import { PhpFileBuilder } from './builder';
import { renderPhpFile } from './render';
import type { PhpFileMetadata } from './types';

const DEFAULT_DOC_HEADER = [
	'AUTO-GENERATED by WP Kernel CLI.',
	'Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.',
];

const INDENT = '        ';

export async function emitPhpArtifacts(context: PrinterContext): Promise<void> {
	const phpRoot = path.resolve(context.outputDir, 'php');
	await fs.mkdir(phpRoot, { recursive: true });

	const namespaceRoot = context.ir.php.namespace;

	const baseControllerPath = path.join(phpRoot, 'Rest', 'BaseController.php');
	const baseControllerBuilder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, {
		kind: 'base-controller',
	});
	initialiseBaseController(baseControllerBuilder, context);
	await writePhpArtifact(baseControllerPath, baseControllerBuilder, context);

	const resourceEntries: { className: string; path: string }[] = [];

	for (const resource of context.ir.resources) {
		const className = toPascalCase(resource.name);
		const metadata: PhpFileMetadata = {
			kind: 'resource-controller',
			name: resource.name,
		};

		const builder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, metadata);
		initialiseResourceController(builder, resource, context);

		const filePath = path.join(
			phpRoot,
			'Rest',
			`${className}Controller.php`
		);
		await writePhpArtifact(filePath, builder, context);

		resourceEntries.push({
			className: `${namespaceRoot}\\Rest\\${className}Controller`,
			path: filePath,
		});
	}

	const persistenceBuilder = new PhpFileBuilder(
		`${namespaceRoot}\\Registration`,
		{
			kind: 'persistence-registry',
		}
	);
	initialisePersistenceRegistry(persistenceBuilder, context);
	const persistencePath = path.join(
		phpRoot,
		'Registration',
		'PersistenceRegistry.php'
	);
	await writePhpArtifact(persistencePath, persistenceBuilder, context);

	const indexPath = path.join(phpRoot, 'index.php');
	const indexContents = createPhpIndex(
		indexPath,
		namespaceRoot,
		baseControllerPath,
		resourceEntries,
		persistencePath,
		context
	);
	const formattedIndex = await context.formatPhp(indexPath, indexContents);
	await fs.mkdir(path.dirname(indexPath), { recursive: true });
	await fs.writeFile(indexPath, formattedIndex, 'utf8');
}

function initialiseBaseController(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (namespace: ${context.ir.meta.sanitizedNamespace})`
	);

	const statements = [
		'abstract class BaseController',
		'{',
		`${INDENT}public function get_namespace(): string`,
		`${INDENT}{`,
		`${INDENT}${INDENT}return '${escapeSingleQuotes(context.ir.meta.sanitizedNamespace)}';`,
		`${INDENT}}`,
		'}',
	];

	for (const statement of statements) {
		builder.appendStatement(statement);
	}
}

function initialiseResourceController(
	builder: PhpFileBuilder,
	resource: IRResource,
	context: PrinterContext
): void {
	const schema = context.ir.schemas.find(
		(entry) => entry.key === resource.schemaKey
	);

	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources.${resource.name}`
	);
	builder.appendDocblock(
		`Schema: ${resource.schemaKey} (${resource.schemaProvenance})`
	);

	for (const route of resource.routes) {
		builder.appendDocblock(`Route: [${route.method}] ${route.path}`);
	}

	const className = `${toPascalCase(resource.name)}Controller`;
	builder.appendStatement(`class ${className} extends BaseController`);
	builder.appendStatement('{');

	builder.appendStatement(
		`${INDENT}public function get_resource_name(): string`
	);
	builder.appendStatement(`${INDENT}{`);
	builder.appendStatement(
		`${INDENT}${INDENT}return '${escapeSingleQuotes(resource.name)}';`
	);
	builder.appendStatement(`${INDENT}}`);

	builder.appendStatement('');
	builder.appendStatement(
		`${INDENT}public function get_schema_key(): string`
	);
	builder.appendStatement(`${INDENT}{`);
	builder.appendStatement(
		`${INDENT}${INDENT}return '${escapeSingleQuotes(resource.schemaKey)}';`
	);
	builder.appendStatement(`${INDENT}}`);

	builder.appendStatement('');
	builder.appendStatement(`${INDENT}public function get_rest_args(): array`);
	builder.appendStatement(`${INDENT}{`);

	if (schema) {
		const restArgs = buildRestArgsPayload(schema, resource);
		const payloadLines = renderJsonDecode(restArgs, 2);
		for (const line of payloadLines) {
			builder.appendStatement(line);
		}
	} else {
		builder.appendStatement(`${INDENT}${INDENT}return [];`);
	}

	builder.appendStatement(`${INDENT}}`);
	builder.appendStatement('}');
}

function initialisePersistenceRegistry(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (storage + identity metadata)`
	);

	builder.appendStatement('final class PersistenceRegistry');
	builder.appendStatement('{');
	builder.appendStatement(
		`${INDENT}public static function get_config(): array`
	);
	builder.appendStatement(`${INDENT}{`);

	const payload = buildPersistencePayload(context);
	const payloadLines = renderJsonDecode(payload, 2);
	for (const line of payloadLines) {
		builder.appendStatement(line);
	}

	builder.appendStatement(`${INDENT}}`);
	builder.appendStatement('}');
}

async function writePhpArtifact(
	filePath: string,
	builder: PhpFileBuilder,
	context: PrinterContext
): Promise<void> {
	const adapterContext = ensureAdapterContext(context);

	if (context.phpAdapter?.customise) {
		context.phpAdapter.customise(builder, adapterContext);
	}

	const ast = builder.toAst();
	const rendered = renderPhpFile(ast);
	const formatted = await context.formatPhp(filePath, rendered);
	await fs.mkdir(path.dirname(filePath), { recursive: true });
	await fs.writeFile(filePath, formatted, 'utf8');
}

function ensureAdapterContext(
	context: PrinterContext
): AdapterContext & { ir: PrinterContext['ir'] } {
	if (context.adapterContext) {
		return context.adapterContext;
	}

	const adapterContext: AdapterContext & {
		ir: PrinterContext['ir'];
	} = {
		config: context.ir.config,
		reporter: createNoopReporter(),
		namespace: context.ir.meta.sanitizedNamespace,
		ir: context.ir,
	};

	context.adapterContext = adapterContext;

	return adapterContext;
}

function createPhpIndex(
	indexPath: string,
	namespaceRoot: string,
	baseControllerPath: string,
	resourceEntries: { className: string; path: string }[],
	persistencePath: string,
	context: PrinterContext
): string {
	const indexDir = path.dirname(indexPath);

	const entries = [
		{
			className: `${namespaceRoot}\\Rest\\BaseController`,
			path: baseControllerPath,
		},
		...resourceEntries,
		{
			className: `${namespaceRoot}\\Registration\\PersistenceRegistry`,
			path: persistencePath,
		},
	];

	const lines: string[] = ['<?php', 'declare(strict_types=1);', ''];
	lines.push('/**');
	for (const line of DEFAULT_DOC_HEADER) {
		lines.push(` * ${line}`);
	}
	lines.push(` * Source: ${context.ir.meta.origin} → php/index`);
	lines.push(' */', '', 'return [');

	for (const entry of entries) {
		const relative = path
			.relative(indexDir, entry.path)
			.split(path.sep)
			.join('/');
		const suffix = relative.startsWith('/') ? relative : `/${relative}`;
		lines.push(`${INDENT}'${entry.className}' => __DIR__ . '${suffix}',`);
	}

	lines.push('];', '');
	return lines.join('\n');
}

function buildRestArgsPayload(schema: IRSchema, resource: IRResource): unknown {
	const schemaValue = schema.schema;
	if (!isRecord(schemaValue)) {
		return {};
	}

	const required = new Set(
		Array.isArray(schemaValue.required)
			? (schemaValue.required as string[])
			: []
	);

	const properties = isRecord(schemaValue.properties)
		? (schemaValue.properties as Record<string, unknown>)
		: {};

	const restArgs: Record<string, unknown> = {};
	for (const [key, descriptor] of Object.entries(properties)) {
		const payload: Record<string, unknown> = {};
		payload.schema = sanitizeJson(descriptor);
		if (required.has(key)) {
			payload.required = true;
		}

		if (resource.identity?.param === key) {
			payload.identity = resource.identity;
		}

		restArgs[key] = payload;
	}

	return restArgs;
}

function buildPersistencePayload(context: PrinterContext): unknown {
	const resources: Record<string, unknown> = {};

	for (const resource of context.ir.resources) {
		if (!resource.storage && !resource.identity) {
			continue;
		}

		resources[resource.name] = sanitizeJson({
			storage: resource.storage ?? null,
			identity: resource.identity ?? null,
		});
	}

	return { resources };
}

function renderJsonDecode(value: unknown, indentLevel: number): string[] {
	const json = JSON.stringify(sortValue(value), null, 2).replace(
		/\r\n/g,
		'\n'
	);
	const escaped = json.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
	const indent = INDENT.repeat(indentLevel);
	const inner = INDENT.repeat(indentLevel + 1);

	return [
		`${indent}return json_decode(`,
		`${inner}'${escaped}',`,
		`${inner}true,`,
		`${inner}512,`,
		`${inner}JSON_THROW_ON_ERROR`,
		`${indent});`,
	];
}

function sanitizeJson(value: unknown): unknown {
	if (Array.isArray(value)) {
		return value.map((entry) => sanitizeJson(entry));
	}

	if (isRecord(value)) {
		const entries = Object.entries(value)
			.map(([key, val]) => [key, sanitizeJson(val)] as const)
			.sort(([a], [b]) => a.localeCompare(b));
		return Object.fromEntries(entries);
	}

	return value;
}

function sortValue(value: unknown): unknown {
	if (Array.isArray(value)) {
		return value.map((entry) => sortValue(entry));
	}

	if (isRecord(value)) {
		return Object.fromEntries(
			Object.entries(value)
				.map(([key, val]) => [key, sortValue(val)] as const)
				.sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
		);
	}

	return value;
}

function isRecord(value: unknown): value is Record<string, unknown> {
	return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}

function toPascalCase(value: string): string {
	return (
		value
			.split(/[^a-zA-Z0-9]+/u)
			.filter(Boolean)
			.map(
				(segment) => segment.charAt(0).toUpperCase() + segment.slice(1)
			)
			.join('') || 'Resource'
	);
}

function escapeSingleQuotes(value: string): string {
	return value.replace(/'/g, "\\'");
}
