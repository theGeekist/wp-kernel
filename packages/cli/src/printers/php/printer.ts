import path from 'node:path';
import { createNoopReporter } from '@geekist/wp-kernel';
import type { Reporter } from '@geekist/wp-kernel';
import type { AdapterContext } from '../../config/types';
import type { IRResource, IRRoute, IRSchema } from '../../ir';
import type { PrinterContext } from '../types';
import { PhpFileBuilder } from './builder';
import { renderPhpFile } from './render';
import { createMethodTemplate, PHP_INDENT } from './template';
import { createWpPostHandlers } from './wp-post';
import type { PhpFileMetadata } from './types';

const DEFAULT_DOC_HEADER = [
	'AUTO-GENERATED by WP Kernel CLI.',
	'Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.',
];

const INDENT = PHP_INDENT;

export async function emitPhpArtifacts(context: PrinterContext): Promise<void> {
	const phpRoot = path.resolve(context.outputDir, 'php');
	await context.ensureDirectory(phpRoot);

	const namespaceRoot = context.ir.php.namespace;
	const reporter =
		ensureAdapterContext(context).reporter.child('printers.php');

	const baseControllerPath = path.join(phpRoot, 'Rest', 'BaseController.php');
	const baseControllerBuilder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, {
		kind: 'base-controller',
	});
	initialiseBaseController(baseControllerBuilder, context);
	await writePhpArtifact(baseControllerPath, baseControllerBuilder, context);

	const resourceEntries: { className: string; path: string }[] = [];

	for (const resource of context.ir.resources) {
		const localRoutes = resource.routes.filter(
			(route) => route.transport === 'local'
		);

		if (localRoutes.length === 0) {
			continue;
		}

		warnOnMissingPolicies({ reporter, resource, routes: localRoutes });

		const className = toPascalCase(resource.name);
		const metadata: PhpFileMetadata = {
			kind: 'resource-controller',
			name: resource.name,
		};

		const builder = new PhpFileBuilder(`${namespaceRoot}\\Rest`, metadata);
		initialiseResourceController(builder, resource, localRoutes, context);

		const filePath = path.join(
			phpRoot,
			'Rest',
			`${className}Controller.php`
		);
		await writePhpArtifact(filePath, builder, context);

		resourceEntries.push({
			className: `${namespaceRoot}\\Rest\\${className}Controller`,
			path: filePath,
		});
	}

	const persistenceBuilder = new PhpFileBuilder(
		`${namespaceRoot}\\Registration`,
		{
			kind: 'persistence-registry',
		}
	);
	initialisePersistenceRegistry(persistenceBuilder, context);
	const persistencePath = path.join(
		phpRoot,
		'Registration',
		'PersistenceRegistry.php'
	);
	await writePhpArtifact(persistencePath, persistenceBuilder, context);

	const indexPath = path.join(phpRoot, 'index.php');
	const indexContents = createPhpIndex(
		indexPath,
		namespaceRoot,
		baseControllerPath,
		resourceEntries,
		persistencePath,
		context
	);
	const formattedIndex = await context.formatPhp(indexPath, indexContents);
	await context.ensureDirectory(path.dirname(indexPath));
	await context.writeFile(indexPath, formattedIndex);
}

function initialiseBaseController(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (namespace: ${context.ir.meta.sanitizedNamespace})`
	);

	builder.appendStatement('abstract class BaseController');
	builder.appendStatement('{');

	const methods = [
		createMethodTemplate({
			signature: 'public function get_namespace(): string',
			indentLevel: 1,
			indentUnit: INDENT,
			body: (body) => {
				body.line(
					`return '${escapeSingleQuotes(context.ir.meta.sanitizedNamespace)}';`
				);
			},
		}),
	];

	for (const [index, method] of methods.entries()) {
		for (const line of method) {
			builder.appendStatement(line);
		}

		if (index < methods.length - 1) {
			builder.appendStatement('');
		}
	}

	builder.appendStatement('}');
}

function initialiseResourceController(
	builder: PhpFileBuilder,
	resource: IRResource,
	routes: IRRoute[],
	context: PrinterContext
): void {
	const schema = context.ir.schemas.find(
		(entry) => entry.key === resource.schemaKey
	);

	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources.${resource.name}`
	);
	builder.appendDocblock(
		`Schema: ${resource.schemaKey} (${resource.schemaProvenance})`
	);

	for (const route of routes) {
		builder.appendDocblock(`Route: [${route.method}] ${route.path}`);
	}

	const className = `${toPascalCase(resource.name)}Controller`;
	builder.appendStatement(`class ${className} extends BaseController`);
	builder.appendStatement('{');

	const methods: string[][] = [];

	methods.push(
		createMethodTemplate({
			signature: 'public function get_resource_name(): string',
			indentLevel: 1,
			indentUnit: INDENT,
			body: (body) => {
				body.line(`return '${escapeSingleQuotes(resource.name)}';`);
			},
		})
	);

	methods.push(
		createMethodTemplate({
			signature: 'public function get_schema_key(): string',
			indentLevel: 1,
			indentUnit: INDENT,
			body: (body) => {
				body.line(
					`return '${escapeSingleQuotes(resource.schemaKey)}';`
				);
			},
		})
	);

	methods.push(
		createMethodTemplate({
			signature: 'public function get_rest_args(): array',
			indentLevel: 1,
			indentUnit: INDENT,
			body: (body) => {
				if (schema) {
					const restArgs = buildRestArgsPayload(schema, resource);
					const payloadLines = renderPhpReturn(restArgs, 2);
					for (const line of payloadLines) {
						body.raw(line);
					}
				} else {
					body.line('return [];');
				}
			},
		})
	);

	const routeMethods = createRouteHandlers({
		builder,
		context,
		resource,
		routes,
	});
	methods.push(...routeMethods);

	for (const [index, method] of methods.entries()) {
		for (const line of method) {
			builder.appendStatement(line);
		}

		if (index < methods.length - 1) {
			builder.appendStatement('');
		}
	}

	builder.appendStatement('}');
}

function initialisePersistenceRegistry(
	builder: PhpFileBuilder,
	context: PrinterContext
): void {
	builder.appendDocblock(DEFAULT_DOC_HEADER[0]!);
	builder.appendDocblock(DEFAULT_DOC_HEADER[1]!);
	builder.appendDocblock(
		`Source: ${context.ir.meta.origin} → resources (storage + identity metadata)`
	);

	builder.appendStatement('final class PersistenceRegistry');
	builder.appendStatement('{');
	builder.appendStatement(
		`${INDENT}public static function get_config(): array`
	);
	builder.appendStatement(`${INDENT}{`);

	const payload = buildPersistencePayload(context);
	const payloadLines = renderPhpReturn(payload, 2);
	for (const line of payloadLines) {
		builder.appendStatement(line);
	}

	builder.appendStatement(`${INDENT}}`);
	builder.appendStatement('}');
}

async function writePhpArtifact(
	filePath: string,
	builder: PhpFileBuilder,
	context: PrinterContext
): Promise<void> {
	const adapterContext = ensureAdapterContext(context);

	if (context.phpAdapter?.customise) {
		context.phpAdapter.customise(builder, adapterContext);
	}

	const ast = builder.toAst();
	const rendered = renderPhpFile(ast);
	const formatted = await context.formatPhp(filePath, rendered);
	await context.ensureDirectory(path.dirname(filePath));
	await context.writeFile(filePath, formatted);
}

function ensureAdapterContext(
	context: PrinterContext
): AdapterContext & { ir: PrinterContext['ir'] } {
	if (context.adapterContext) {
		const adapterContext: AdapterContext & {
			ir: PrinterContext['ir'];
		} = {
			...context.adapterContext,
			config: context.adapterContext.config ?? context.ir.config,
			reporter: isReporter(context.adapterContext.reporter)
				? context.adapterContext.reporter
				: createNoopReporter(),
			namespace:
				context.adapterContext.namespace ??
				context.ir.meta.sanitizedNamespace,
			ir: context.adapterContext.ir ?? context.ir,
		};

		context.adapterContext = adapterContext;

		return adapterContext;
	}

	const adapterContext: AdapterContext & {
		ir: PrinterContext['ir'];
	} = {
		config: context.ir.config,
		reporter: createNoopReporter(),
		namespace: context.ir.meta.sanitizedNamespace,
		ir: context.ir,
	};

	context.adapterContext = adapterContext;

	return adapterContext;
}

function isReporter(value: unknown): value is Reporter {
	if (!value || typeof value !== 'object') {
		return false;
	}

	const candidate = value as Record<string, unknown>;
	return (
		typeof candidate.info === 'function' &&
		typeof candidate.warn === 'function' &&
		typeof candidate.error === 'function' &&
		typeof candidate.debug === 'function' &&
		typeof candidate.child === 'function'
	);
}

function createPhpIndex(
	indexPath: string,
	namespaceRoot: string,
	baseControllerPath: string,
	resourceEntries: { className: string; path: string }[],
	persistencePath: string,
	context: PrinterContext
): string {
	const indexDir = path.dirname(indexPath);

	const entries = [
		{
			className: `${namespaceRoot}\\Rest\\BaseController`,
			path: baseControllerPath,
		},
		...resourceEntries,
		{
			className: `${namespaceRoot}\\Registration\\PersistenceRegistry`,
			path: persistencePath,
		},
	];

	const lines: string[] = ['<?php', 'declare(strict_types=1);', ''];
	lines.push('/**');
	for (const line of DEFAULT_DOC_HEADER) {
		lines.push(` * ${line}`);
	}
	lines.push(` * Source: ${context.ir.meta.origin} → php/index`);
	lines.push(' */', '', 'return [');

	for (const entry of entries) {
		const relative = path
			.relative(indexDir, entry.path)
			.split(path.sep)
			.join('/');
		const suffix = relative.startsWith('/') ? relative : `/${relative}`;
		lines.push(`${INDENT}'${entry.className}' => __DIR__ . '${suffix}',`);
	}

	lines.push('];', '');
	return lines.join('\n');
}

function buildRestArgsPayload(schema: IRSchema, resource: IRResource): unknown {
	const schemaValue = schema.schema;
	if (!isRecord(schemaValue)) {
		return {};
	}

	const required = new Set(
		Array.isArray(schemaValue.required)
			? (schemaValue.required as string[])
			: []
	);

	const properties = isRecord(schemaValue.properties)
		? (schemaValue.properties as Record<string, unknown>)
		: {};

	const restArgs: Record<string, unknown> = {};
	for (const [key, descriptor] of Object.entries(properties)) {
		const payload: Record<string, unknown> = {};
		payload.schema = sanitizeJson(descriptor);
		if (required.has(key)) {
			payload.required = true;
		}

		if (resource.identity?.param === key) {
			payload.identity = resource.identity;
		}

		restArgs[key] = payload;
	}

	if (resource.queryParams) {
		applyQueryParamsToRestArgs(restArgs, resource.queryParams);
	}

	return restArgs;
}

function applyQueryParamsToRestArgs(
	restArgs: Record<string, unknown>,
	queryParams: NonNullable<IRResource['queryParams']>
): void {
	for (const [param, descriptor] of Object.entries(queryParams)) {
		const existing = isRecord(restArgs[param])
			? { ...(restArgs[param] as Record<string, unknown>) }
			: {};

		const schemaPayload = isRecord(existing.schema)
			? { ...(existing.schema as Record<string, unknown>) }
			: {};

		if (descriptor.type === 'enum') {
			schemaPayload.type = 'string';
			if (descriptor.enum) {
				schemaPayload.enum = Array.from(descriptor.enum);
			}
		} else {
			schemaPayload.type = descriptor.type;
		}

		if (descriptor.description) {
			existing.description = descriptor.description;
		}

		if (!descriptor.optional) {
			existing.required = true;
		}

		existing.schema = sanitizeJson(schemaPayload);
		restArgs[param] = sanitizeJson(existing);
	}
}

function buildPersistencePayload(context: PrinterContext): unknown {
	const resources: Record<string, unknown> = {};

	for (const resource of context.ir.resources) {
		if (!resource.storage && !resource.identity) {
			continue;
		}

		resources[resource.name] = sanitizeJson({
			storage: resource.storage ?? null,
			identity: resource.identity ?? null,
		});
	}

	return { resources };
}

function renderPhpReturn(value: unknown, indentLevel: number): string[] {
	const expressionLines = renderPhpExpression(value, indentLevel);

	const indent = INDENT.repeat(indentLevel);
	const firstLine = expressionLines[0]!;
	const remainder = firstLine.slice(indent.length);
	expressionLines[0] = `${indent}return ${remainder}`;

	const lastIndex = expressionLines.length - 1;
	expressionLines[lastIndex] = `${expressionLines[lastIndex]};`;

	return expressionLines;
}

function renderPhpExpression(value: unknown, indentLevel: number): string[] {
	const indent = INDENT.repeat(indentLevel);

	if (Array.isArray(value)) {
		return renderPhpList(value, indentLevel, indent);
	}

	if (isRecord(value)) {
		return renderPhpAssociative(
			value as Record<string, unknown>,
			indentLevel,
			indent
		);
	}

	return renderPhpScalar(value, indent);
}

function renderPhpList(
	value: unknown[],
	indentLevel: number,
	indent: string
): string[] {
	if (value.length === 0) {
		return [`${indent}[]`];
	}

	const lines = [`${indent}[`];
	for (const entry of value) {
		const rendered = renderPhpExpression(entry, indentLevel + 1);
		const last = rendered.length - 1;
		rendered[last] = `${rendered[last]},`;
		lines.push(...rendered);
	}

	lines.push(`${indent}]`);
	return lines;
}

function renderPhpAssociative(
	value: Record<string, unknown>,
	indentLevel: number,
	indent: string
): string[] {
	const entries = Object.entries(value);
	if (entries.length === 0) {
		return [`${indent}[]`];
	}

	const lines = [`${indent}[`];
	const childIndent = INDENT.repeat(indentLevel + 1);

	for (const [key, val] of entries) {
		const rendered = renderPhpExpression(val, indentLevel + 1);
		if (rendered.length === 0) {
			continue;
		}
		const firstLine = rendered[0]!;
		const remainder = firstLine.slice(childIndent.length);
		rendered[0] = `${childIndent}'${escapeSingleQuotes(key)}' => ${remainder}`;
		const last = rendered.length - 1;
		rendered[last] = `${rendered[last]},`;
		lines.push(...rendered);
	}

	lines.push(`${indent}]`);
	return lines;
}

function renderPhpScalar(value: unknown, indent: string): string[] {
	if (typeof value === 'string') {
		return [`${indent}'${escapeSingleQuotes(value)}'`];
	}

	if (typeof value === 'number') {
		if (!Number.isFinite(value)) {
			throw new Error('Cannot render non-finite numbers in PHP output.');
		}

		return [`${indent}${value}`];
	}

	if (typeof value === 'bigint') {
		return [`${indent}${value.toString()}`];
	}

	if (typeof value === 'boolean') {
		return [`${indent}${value ? 'true' : 'false'}`];
	}

	if (value === null) {
		return [`${indent}null`];
	}

	throw new Error(`Unsupported PHP value: ${String(value)}`);
}

function sanitizeJson(value: unknown): unknown {
	if (Array.isArray(value)) {
		return value.map((entry) => sanitizeJson(entry));
	}

	if (isRecord(value)) {
		const entries = Object.entries(value)
			.map(([key, val]) => [key, sanitizeJson(val)] as const)
			.sort(([a], [b]) => a.localeCompare(b));
		return Object.fromEntries(entries);
	}

	return value;
}

function isRecord(value: unknown): value is Record<string, unknown> {
	return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}

function toPascalCase(value: string): string {
	return (
		value
			.split(/[^a-zA-Z0-9]+/u)
			.filter(Boolean)
			.map(
				(segment) => segment.charAt(0).toUpperCase() + segment.slice(1)
			)
			.join('') || 'Resource'
	);
}

function createRouteHandlers(options: {
	builder: PhpFileBuilder;
	context: PrinterContext;
	resource: IRResource;
	routes: IRRoute[];
}): string[][] {
	if (options.resource.storage?.mode === 'wp-post') {
		const routeDefinitions = options.routes.map((route) => ({
			route,
			methodName: createRouteMethodName(route, options.context),
		}));

		return createWpPostHandlers({
			builder: options.builder,
			context: options.context,
			resource: options.resource,
			routes: routeDefinitions,
		});
	}

	return createRouteStubs(options);
}

function createRouteStubs(options: {
	builder: PhpFileBuilder;
	context: PrinterContext;
	resource: IRResource;
	routes: IRRoute[];
}): string[][] {
	const { builder, resource, routes } = options;

	builder.addUse('WP_Error');
	builder.addUse('WP_REST_Request');

	const methodTemplates: string[][] = [];

	for (const route of routes) {
		methodTemplates.push(
			createMethodTemplate({
				signature: `public function ${createRouteMethodName(
					route,
					options.context
				)}( WP_REST_Request $request )`,
				indentLevel: 1,
				indentUnit: INDENT,
				docblock: [`Handle [${route.method}] ${route.path}.`],
				body: (body) => {
					if (routeUsesIdentity(route, resource.identity)) {
						const param = resource.identity?.param ?? 'id';
						body.line(
							`$${param} = $request->get_param( '${param}' );`
						);
						body.blank();
					}

					body.line(
						`// TODO: Implement handler for [${route.method}] ${route.path}.`
					);
					body.line("return new WP_Error( 501, 'Not Implemented' );");
				},
			})
		);
	}

	return methodTemplates;
}

function createRouteMethodName(
	route: IRRoute,
	context: PrinterContext
): string {
	const method = route.method.toLowerCase();
	const segments = deriveRouteSegments(route.path, context);
	const suffix = segments.map(toPascalCase).join('') || 'Route';
	return `${method}${suffix}`;
}

function deriveRouteSegments(
	routePath: string,
	context: PrinterContext
): string[] {
	const trimmed = routePath.replace(/^\/+/, '');
	if (!trimmed) {
		return [];
	}

	const segments = trimmed
		.split('/')
		.filter(Boolean)
		.map((segment) => segment.replace(/^:/, ''));

	const namespaceVariants = new Set(
		[
			context.ir.meta.namespace,
			context.ir.meta.namespace.replace(/\\/g, '/'),
			context.ir.meta.sanitizedNamespace,
			context.ir.meta.sanitizedNamespace.replace(/\\/g, '/'),
		]
			.map((value) =>
				value
					.split('/')
					.filter(Boolean)
					.map((segment) => segment.toLowerCase())
			)
			.map((variant) => variant.join('/'))
	);

	const normalisedSegments = segments.map((segment) => segment.toLowerCase());

	for (const variant of namespaceVariants) {
		const variantSegments = variant.split('/');
		let matches = true;
		for (let index = 0; index < variantSegments.length; index += 1) {
			if (normalisedSegments[index] !== variantSegments[index]) {
				matches = false;
				break;
			}
		}

		if (matches) {
			return segments.slice(variantSegments.length);
		}
	}

	return segments;
}

function routeUsesIdentity(
	route: IRRoute,
	identity: IRResource['identity']
): boolean {
	if (!identity?.param) {
		return false;
	}

	const placeholder = `:${identity.param.toLowerCase()}`;
	return route.path.toLowerCase().includes(placeholder);
}

function warnOnMissingPolicies(options: {
	reporter: Reporter;
	resource: IRResource;
	routes: IRRoute[];
}): void {
	const { reporter, resource, routes } = options;

	for (const route of routes) {
		if (!isWriteRoute(route.method) || route.policy) {
			continue;
		}

		reporter.warn('Write route missing policy.', {
			resource: resource.name,
			method: route.method,
			path: route.path,
		});
	}
}

function isWriteRoute(method: string): boolean {
	switch (method) {
		case 'POST':
		case 'PUT':
		case 'PATCH':
		case 'DELETE':
			return true;
		default:
			return false;
	}
}

function escapeSingleQuotes(value: string): string {
	return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}
